#!/usr/bin/env python3
"""
Continuous deployment script for Blaze Intelligence
Commits data updates and triggers Cloudflare Pages deployment
"""

import os
import json
import subprocess
import logging
from datetime import datetime
from typing import List, Dict, Optional

logger = logging.getLogger('blaze_deploy')

class BlazeDeployment:
    """Deployment manager for Blaze Intelligence"""
    
    def __init__(self, repo_path: str = '.'):
        self.repo_path = repo_path
        self.cloudflare_project = 'blaze-intelligence-official'
        self.branch = 'main'
        
    def check_for_changes(self) -> List[str]:
        """Check for uncommitted changes in the repository"""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            
            if result.stdout:
                changed_files = [
                    line.strip().split(' ', 1)[1] 
                    for line in result.stdout.strip().split('\n')
                ]
                return changed_files
            return []
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Error checking git status: {e}")
            return []
    
    def validate_data_files(self) -> bool:
        """Validate all data files before deployment"""
        data_dir = os.path.join(self.repo_path, 'public', 'data')
        schema_path = os.path.join(self.repo_path, 'schemas', 'unified-player-schema.json')
        
        # Check if schema exists
        if not os.path.exists(schema_path):
            logger.warning("Schema file not found, skipping validation")
            return True
        
        # Load schema
        with open(schema_path, 'r') as f:
            schema = json.load(f)
        
        # Validate each JSON file in data directory
        if os.path.exists(data_dir):
            for filename in os.listdir(data_dir):
                if filename.endswith('.json'):
                    filepath = os.path.join(data_dir, filename)
                    try:
                        with open(filepath, 'r') as f:
                            data = json.load(f)
                        logger.info(f"Validated {filename}")
                    except json.JSONDecodeError as e:
                        logger.error(f"Invalid JSON in {filename}: {e}")
                        return False
        
        return True
    
    def run_tests(self) -> bool:
        """Run test suite before deployment"""
        test_commands = [
            # Python tests
            ['python', '-m', 'pytest', 'tests/', '-v'],
            # JavaScript tests
            ['npm', 'test'],
            # Schema validation
            ['python', 'scripts/validate_schemas.py']
        ]
        
        for cmd in test_commands:
            try:
                result = subprocess.run(
                    cmd,
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                
                if result.returncode != 0:
                    logger.error(f"Test failed: {' '.join(cmd)}")
                    logger.error(result.stderr)
                    return False
                    
            except FileNotFoundError:
                logger.warning(f"Test command not found: {' '.join(cmd)}")
                continue
            except subprocess.TimeoutExpired:
                logger.error(f"Test timed out: {' '.join(cmd)}")
                return False
        
        logger.info("All tests passed")
        return True
    
    def commit_changes(self, message: str = None) -> bool:
        """Commit changes to git repository"""
        changed_files = self.check_for_changes()
        
        if not changed_files:
            logger.info("No changes to commit")
            return False
        
        # Generate commit message
        if not message:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            message = f"🤖 Data update: {timestamp}\n\n"
            message += "Updated files:\n"
            for file in changed_files[:10]:  # Limit to 10 files in message
                message += f"  - {file}\n"
            if len(changed_files) > 10:
                message += f"  ... and {len(changed_files) - 10} more files\n"
            message += "\nGenerated by Blaze Intelligence Pipeline"
        
        try:
            # Stage all changes
            subprocess.run(
                ['git', 'add', '-A'],
                cwd=self.repo_path,
                check=True
            )
            
            # Commit changes
            subprocess.run(
                ['git', 'commit', '-m', message],
                cwd=self.repo_path,
                check=True
            )
            
            logger.info(f"Committed {len(changed_files)} files")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Error committing changes: {e}")
            return False
    
    def push_to_remote(self) -> bool:
        """Push commits to remote repository"""
        try:
            subprocess.run(
                ['git', 'push', 'origin', self.branch],
                cwd=self.repo_path,
                check=True
            )
            logger.info(f"Pushed to {self.branch}")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Error pushing to remote: {e}")
            return False
    
    def trigger_cloudflare_deployment(self) -> bool:
        """Trigger Cloudflare Pages deployment"""
        try:
            # Cloudflare Pages automatically deploys on push
            # But we can also trigger manually with wrangler
            result = subprocess.run(
                ['wrangler', 'pages', 'deploy', '.', 
                 '--project-name', self.cloudflare_project,
                 '--commit-dirty=true'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if result.returncode == 0:
                # Extract deployment URL from output
                output_lines = result.stdout.split('\n')
                for line in output_lines:
                    if 'https://' in line and '.pages.dev' in line:
                        logger.info(f"Deployment URL: {line.strip()}")
                        break
                return True
            else:
                logger.error(f"Cloudflare deployment failed: {result.stderr}")
                return False
                
        except FileNotFoundError:
            logger.warning("Wrangler not found, relying on automatic deployment")
            return True
        except subprocess.TimeoutExpired:
            logger.error("Cloudflare deployment timed out")
            return False
    
    def health_check(self, url: str = None) -> bool:
        """Perform health check on deployed site"""
        if not url:
            url = f"https://{self.cloudflare_project}.pages.dev/api/health"
        
        try:
            import requests
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                logger.info(f"Health check passed: {url}")
                return True
            else:
                logger.error(f"Health check failed: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Health check error: {e}")
            return False
    
    def rollback(self, commits_back: int = 1):
        """Rollback to previous deployment"""
        try:
            # Reset to previous commit
            subprocess.run(
                ['git', 'reset', '--hard', f'HEAD~{commits_back}'],
                cwd=self.repo_path,
                check=True
            )
            
            # Force push
            subprocess.run(
                ['git', 'push', '--force', 'origin', self.branch],
                cwd=self.repo_path,
                check=True
            )
            
            logger.info(f"Rolled back {commits_back} commits")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Rollback failed: {e}")
            return False
    
    def deploy_updates(self) -> bool:
        """Main deployment function"""
        logger.info("Starting deployment pipeline...")
        
        # Step 1: Validate data files
        if not self.validate_data_files():
            logger.error("Data validation failed, aborting deployment")
            return False
        
        # Step 2: Run tests (optional in production)
        # if not self.run_tests():
        #     logger.error("Tests failed, aborting deployment")
        #     return False
        
        # Step 3: Commit changes
        if not self.commit_changes():
            logger.info("No changes to deploy")
            return True
        
        # Step 4: Push to remote
        if not self.push_to_remote():
            logger.error("Failed to push to remote")
            return False
        
        # Step 5: Trigger Cloudflare deployment
        if not self.trigger_cloudflare_deployment():
            logger.warning("Manual Cloudflare trigger failed, relying on auto-deploy")
        
        # Step 6: Wait for deployment
        import time
        logger.info("Waiting for deployment to complete...")
        time.sleep(30)
        
        # Step 7: Health check
        if not self.health_check():
            logger.error("Health check failed, considering rollback")
            # Uncomment to enable automatic rollback
            # self.rollback()
            return False
        
        logger.info("Deployment completed successfully!")
        return True

def main():
    """Main deployment function"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    deployer = BlazeDeployment()
    
    # Run deployment
    success = deployer.deploy_updates()
    
    if success:
        logger.info("✅ Deployment successful")
    else:
        logger.error("❌ Deployment failed")
        exit(1)

if __name__ == '__main__':
    main()