<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lone Star Legends - Claude-Powered Three.js Baseball Simulator</title>
    <style>
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .scoreboard {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid gold;
            border-radius: 10px;
            padding: 15px 30px;
            color: white;
            pointer-events: auto;
        }
        
        .score-display {
            display: flex;
            justify-content: space-around;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .team-score {
            text-align: center;
            margin: 0 20px;
        }
        
        .team-name {
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .inning-display {
            text-align: center;
            font-size: 14px;
            color: #aaa;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            position: relative;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn.loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .btn.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            margin: auto;
            border: 2px solid transparent;
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: button-loading-spinner 1s ease infinite;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        @keyframes button-loading-spinner {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .enigma-panel {
            position: absolute;
            right: 20px;
            top: 100px;
            width: 280px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 15px;
            color: white;
            pointer-events: auto;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .enigma-title {
            font-size: 16px;
            color: #9b59b6;
            margin-bottom: 15px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .enigma-score {
            font-size: 24px;
            color: #e74c3c;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .enigma-metric {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .enigma-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .enigma-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71);
            transition: width 0.5s ease;
        }
        
        .ai-narrative {
            position: absolute;
            left: 20px;
            bottom: 150px;
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            color: white;
            pointer-events: none;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .narrative-title {
            color: #3498db;
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .narrative-content {
            font-size: 12px;
            line-height: 1.4;
            font-style: italic;
        }
        
        .ai-commentary {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px 20px;
            color: #ffd700;
            text-align: center;
            font-style: italic;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .ai-commentary.active {
            opacity: 1;
        }
        
        .claude-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .momentum-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 15px;
            overflow: hidden;
            pointer-events: none;
        }
        
        .momentum-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2 0%, #ff6b6b 100%);
            width: 50%;
            transition: width 0.5s ease;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
        }
        
        .camera-controls {
            position: absolute;
            left: 20px;
            top: 100px;
            pointer-events: auto;
        }
        
        .camera-btn {
            display: block;
            margin: 5px 0;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #4a90e2;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .camera-btn:hover {
            background: rgba(74, 144, 226, 0.3);
        }
        
        .camera-btn.active {
            background: #4a90e2;
        }
        
        .stats-mini {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 10px 20px;
            color: white;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Stadium...</div>
    
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div class="claude-badge">
            ðŸ¤– Powered by Claude AI
        </div>
        
        <div class="scoreboard">
            <div class="score-display">
                <div class="team-score">
                    <div class="team-name">LONE STAR LEGENDS</div>
                    <div id="home-score">0</div>
                </div>
                <div class="team-score">
                    <div class="team-name">CHALLENGERS</div>
                    <div id="away-score">0</div>
                </div>
            </div>
            <div class="inning-display">
                Inning: <span id="inning">1</span> - <span id="half">TOP</span>
            </div>
        </div>
        
        <div class="stats-mini">
            <span id="current-batter">Rodriguez</span> at bat | 
            Exit Velocity: <span id="exit-velocity">0 mph</span> | 
            Distance: <span id="distance">0 ft</span>
        </div>
        
        <div class="camera-controls">
            <button class="camera-btn active" onclick="setCamera('broadcast')">Broadcast</button>
            <button class="camera-btn" onclick="setCamera('pitcher')">Pitcher View</button>
            <button class="camera-btn" onclick="setCamera('batter')">Batter View</button>
            <button class="camera-btn" onclick="setCamera('aerial')">Aerial View</button>
        </div>
        
        <div class="enigma-panel">
            <div class="enigma-title">
                ðŸ§  Champion Enigma Engine
            </div>
            <div class="enigma-score" id="champion-quotient">--</div>
            
            <div style="font-size: 11px; margin-bottom: 10px;">
                <div class="enigma-metric">
                    <span>Mental Toughness:</span>
                    <span id="mental-toughness">--</span>
                </div>
                <div class="enigma-bar">
                    <div class="enigma-fill" id="mental-bar" style="width: 0%"></div>
                </div>
                
                <div class="enigma-metric">
                    <span>Killer Instinct:</span>
                    <span id="killer-instinct">--</span>
                </div>
                <div class="enigma-bar">
                    <div class="enigma-fill" id="killer-bar" style="width: 0%"></div>
                </div>
                
                <div class="enigma-metric">
                    <span>Neural Efficiency:</span>
                    <span id="neural-efficiency">--</span>
                </div>
                <div class="enigma-bar">
                    <div class="enigma-fill" id="neural-bar" style="width: 0%"></div>
                </div>
                
                <div class="enigma-metric">
                    <span>Flow State:</span>
                    <span id="flow-state">--</span>
                </div>
                <div class="enigma-bar">
                    <div class="enigma-fill" id="flow-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div style="font-size: 10px; color: #bbb; text-align: center; margin-top: 10px;">
                Real-time biometric analysis
            </div>
        </div>
        
        <div class="ai-narrative">
            <div class="narrative-title">
                ðŸ“– Player Narrative
            </div>
            <div class="narrative-content" id="narrative-content">
                Select a player to view their story...
            </div>
        </div>
        
        <div class="momentum-bar">
            <div class="momentum-fill" id="momentum"></div>
        </div>
        
        <div class="ai-commentary" id="commentary"></div>
        
        <div class="controls">
            <button class="btn" onclick="simulatePitch()">Pitch Ball</button>
            <button class="btn" onclick="simulateHit()">Simulate Hit</button>
            <button class="btn" onclick="generateClaudePlay()">Claude Generate</button>
            <button class="btn" onclick="analyzePlayer()">Player Analysis</button>
            <button class="btn" onclick="resetGame()">Reset Game</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js Baseball Simulator with Claude API Integration
        
        let scene, camera, renderer;
        let stadium, field, baseball;
        let cameras = {};
        let currentCamera = 'broadcast';
        let gameState = {
            homeScore: 0,
            awayScore: 0,
            inning: 1,
            topBottom: 'top',
            outs: 0,
            momentum: 50,
            lastPlay: null,
            currentBatter: 'Rodriguez'
        };
        
        // Player roster for narratives
        const players = {
            home: ['Rodriguez', 'Martinez', 'Johnson', 'Williams', 'Davis'],
            away: ['Smith', 'Brown', 'Jones', 'Miller', 'Moore']
        };
        
        // Initialize Three.js Scene (same as before but enhanced)
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 100, 1500);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            setupCameras();
            setupLighting();
            createStadium();
            createField();
            createBaseball();
            
            document.getElementById('loading').style.display = 'none';
            
            // Initialize with a player analysis
            analyzePlayer();
            generatePlayerNarrative();
            
            animate();
        }
        
        // API Integration Functions
        async function generateClaudePlay() {
            const btn = event.target;
            btn.classList.add('loading');
            btn.textContent = '';
            
            try {
                showCommentary("ðŸ¤– Claude AI generating unique scenario...");
                
                const context = {
                    inning: gameState.inning,
                    home_score: gameState.homeScore,
                    away_score: gameState.awayScore,
                    outs: gameState.outs,
                    runners_on_base: Math.floor(Math.random() * 4)
                };
                
                const response = await fetch('/api/generate-play', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(context)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const scenario = data.scenario;
                    
                    // Show setup
                    showCommentary(scenario.setup);
                    
                    // Simulate the play
                    setTimeout(() => {
                        processAIPlay(scenario);
                        showCommentary(scenario.commentary);
                        
                        // Show biometric data
                        if (scenario.biometric_data) {
                            updateBiometricDisplay(scenario.biometric_data);
                        }
                    }, 3000);
                    
                } else {
                    showCommentary("Error generating AI content. Using fallback scenario.");
                    simulateHit();
                }
                
            } catch (error) {
                console.error('Claude API Error:', error);
                showCommentary("Connection error. Using offline mode.");
                simulateHit();
            } finally {
                btn.classList.remove('loading');
                btn.textContent = 'Claude Generate';
            }
        }
        
        async function analyzePlayer() {
            try {
                const currentTeam = gameState.topBottom === 'top' ? 'away' : 'home';
                const playerName = gameState.currentBatter;
                
                const response = await fetch('/api/player-analysis', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ player_name: playerName })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateEnigmaPanel(data.analysis);
                }
                
            } catch (error) {
                console.error('Analysis Error:', error);
                // Fallback to random data
                updateEnigmaPanel(generateFallbackAnalysis());
            }
        }
        
        async function generatePlayerNarrative() {
            try {
                const playerName = gameState.currentBatter;
                const situations = ['clutch', 'rookie', 'veteran', 'slump'];
                const situation = situations[Math.floor(Math.random() * situations.length)];
                
                const response = await fetch('/api/player-narrative', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        player_name: playerName,
                        situation: situation
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const narrative = data.narrative;
                    document.getElementById('narrative-content').innerHTML = `
                        <strong>Background:</strong> ${narrative.background}<br><br>
                        <strong>Mental State:</strong> ${narrative.mental_state}<br><br>
                        <strong>Prediction:</strong> ${narrative.prediction}
                    `;
                }
                
            } catch (error) {
                console.error('Narrative Error:', error);
            }
        }
        
        async function generateAICommentary(playData) {
            try {
                const response = await fetch('/api/generate-commentary', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(playData)
                });
                
                const data = await response.json();
                
                if (data.success && data.commentary.length > 0) {
                    // Show commentary sequentially
                    for (let i = 0; i < data.commentary.length; i++) {
                        setTimeout(() => {
                            showCommentary(data.commentary[i]);
                        }, i * 2000);
                    }
                } else {
                    showCommentary("What a play!");
                }
                
            } catch (error) {
                console.error('Commentary Error:', error);
                showCommentary("Incredible baseball action!");
            }
        }
        
        function updateEnigmaPanel(analysis) {
            document.getElementById('champion-quotient').textContent = 
                `${analysis.overall_champion_quotient.toFixed(1)}/100`;
            
            const mental = analysis.psychological_profiler.mental_toughness;
            const killer = analysis.psychological_profiler.killer_instinct;
            const neural = analysis.physiological_decoder.neural_efficiency;
            const flow = analysis.physiological_decoder.flow_state_probability;
            
            document.getElementById('mental-toughness').textContent = `${(mental * 100).toFixed(0)}%`;
            document.getElementById('killer-instinct').textContent = `${(killer * 100).toFixed(0)}%`;
            document.getElementById('neural-efficiency').textContent = `${(neural * 100).toFixed(0)}%`;
            document.getElementById('flow-state').textContent = `${(flow * 100).toFixed(0)}%`;
            
            document.getElementById('mental-bar').style.width = `${mental * 100}%`;
            document.getElementById('killer-bar').style.width = `${killer * 100}%`;
            document.getElementById('neural-bar').style.width = `${neural * 100}%`;
            document.getElementById('flow-bar').style.width = `${flow * 100}%`;
        }
        
        function generateFallbackAnalysis() {
            return {
                overall_champion_quotient: Math.random() * 40 + 60,
                psychological_profiler: {
                    mental_toughness: Math.random() * 0.5 + 0.5,
                    killer_instinct: Math.random() * 0.5 + 0.4,
                    pressure_response: Math.random() * 0.6 + 0.4
                },
                physiological_decoder: {
                    neural_efficiency: Math.random() * 0.4 + 0.6,
                    flow_state_probability: Math.random() * 0.5 + 0.5
                }
            };
        }
        
        function updateBiometricDisplay(biometrics) {
            // Visual feedback for biometric data
            const enigmaPanel = document.querySelector('.enigma-panel');
            enigmaPanel.style.borderColor = biometrics.heart_rate > 100 ? '#e74c3c' : '#9b59b6';
            
            // Could add more visual feedback here
        }
        
        function processAIPlay(scenario) {
            const playType = scenario.play_type;
            const drama = scenario.drama;
            
            // Process based on play type
            switch(playType) {
                case 'homerun':
                    const currentTeam = gameState.topBottom === 'top' ? 'away' : 'home';
                    if (currentTeam === 'home') {
                        gameState.homeScore += Math.floor(drama / 3) + 1;
                        gameState.momentum = Math.min(90, gameState.momentum + drama * 2);
                    } else {
                        gameState.awayScore += Math.floor(drama / 3) + 1;
                        gameState.momentum = Math.max(10, gameState.momentum - drama * 2);
                    }
                    
                    // Animate home run
                    animateHitBall(110, 30, 0);
                    
                    if (drama >= 8) {
                        createFireworks();
                    }
                    break;
                    
                case 'single':
                case 'double':
                case 'triple':
                    if (Math.random() < 0.4) {
                        const currentTeam = gameState.topBottom === 'top' ? 'away' : 'home';
                        if (currentTeam === 'home') {
                            gameState.homeScore += 1;
                        } else {
                            gameState.awayScore += 1;
                        }
                    }
                    break;
                    
                case 'strikeout':
                case 'groundout':
                case 'flyout':
                    gameState.outs += 1;
                    if (gameState.outs >= 3) {
                        switchInning();
                    }
                    break;
            }
            
            updateUI();
            switchBatter();
        }
        
        function switchBatter() {
            const currentTeam = gameState.topBottom === 'top' ? 'away' : 'home';
            const roster = players[currentTeam];
            gameState.currentBatter = roster[Math.floor(Math.random() * roster.length)];
            document.getElementById('current-batter').textContent = gameState.currentBatter;
            
            // Generate new narrative for the batter
            setTimeout(() => {
                generatePlayerNarrative();
                analyzePlayer();
            }, 1000);
        }
        
        // Enhanced versions of existing functions
        function simulateHit() {
            const exitVelocity = Math.random() * 40 + 80;
            const launchAngle = Math.random() * 45 + 10;
            const direction = Math.random() * 90 - 45;
            
            document.getElementById('exit-velocity').textContent = `${exitVelocity.toFixed(1)} mph`;
            document.getElementById('launch-angle').textContent = `${launchAngle.toFixed(1)}Â°`;
            
            const distance = calculateDistance(exitVelocity, launchAngle);
            document.getElementById('distance').textContent = `${distance.toFixed(0)} ft`;
            
            animateHitBall(exitVelocity, launchAngle, direction);
            
            const outcome = determineOutcome(distance, direction);
            processPlay(outcome);
            
            // Generate AI commentary
            const playData = {
                exit_velocity: exitVelocity,
                launch_angle: launchAngle,
                direction: direction,
                outcome: outcome
            };
            
            generateAICommentary(playData);
            switchBatter();
        }
        
        // Include all the previous Three.js functions (setupCameras, createStadium, etc.)
        function setupCameras() {
            cameras.broadcast = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            cameras.broadcast.position.set(150, 100, 150);
            cameras.broadcast.lookAt(0, 0, 0);
            
            cameras.pitcher = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            cameras.pitcher.position.set(0, 2, 20);
            cameras.pitcher.lookAt(0, 1, 0);
            
            cameras.batter = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            cameras.batter.position.set(0, 2, -2);
            cameras.batter.lookAt(0, 1, 20);
            
            cameras.aerial = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            cameras.aerial.position.set(0, 300, 0);
            cameras.aerial.lookAt(0, 0, 0);
            
            camera = cameras[currentCamera];
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const stadiumLights = [
                { x: 100, y: 150, z: 100 },
                { x: -100, y: 150, z: 100 },
                { x: 100, y: 150, z: -100 },
                { x: -100, y: 150, z: -100 }
            ];
            
            stadiumLights.forEach(pos => {
                const light = new THREE.SpotLight(0xffffff, 1, 500, Math.PI / 4, 0.5);
                light.position.set(pos.x, pos.y, pos.z);
                light.target.position.set(0, 0, 0);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                scene.add(light);
                scene.add(light.target);
            });
        }
        
        function createStadium() {
            const wallGeometry = new THREE.BoxGeometry(400, 100, 10);
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 50, -200);
            scene.add(backWall);
            
            const sideWallGeometry = new THREE.BoxGeometry(10, 100, 400);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-200, 50, 0);
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(200, 50, 0);
            scene.add(rightWall);
        }
        
        function createField() {
            const fieldGeometry = new THREE.PlaneGeometry(400, 400);
            const fieldMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 });
            
            field = new THREE.Mesh(fieldGeometry, fieldMaterial);
            field.rotation.x = -Math.PI / 2;
            field.receiveShadow = true;
            scene.add(field);
            
            // Add bases
            const baseGeometry = new THREE.BoxGeometry(2, 0.2, 2);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            
            const bases = [
                { x: 30, z: 0 }, { x: 0, z: 30 }, { x: -30, z: 0 }, { x: 0, z: 0 }
            ];
            
            bases.forEach(pos => {
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(pos.x, 0.1, pos.z);
                scene.add(base);
            });
        }
        
        function createBaseball() {
            const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            
            baseball = new THREE.Mesh(ballGeometry, ballMaterial);
            baseball.position.set(0, 1, 18.44);
            scene.add(baseball);
        }
        
        function calculateDistance(velocity, angle) {
            const v0 = velocity * 0.44704;
            const angleRad = angle * Math.PI / 180;
            const g = 9.81;
            const distance = (v0 * v0 * Math.sin(2 * angleRad)) / g;
            return distance * 3.28084;
        }
        
        function animateHitBall(velocity, angle, direction) {
            const startTime = Date.now();
            const duration = 3000;
            
            function update() {
                const elapsed = Date.now() - startTime;
                const t = elapsed / 1000;
                
                if (t < duration / 1000) {
                    const v0 = velocity * 0.44704;
                    const angleRad = angle * Math.PI / 180;
                    const dirRad = direction * Math.PI / 180;
                    
                    const x = v0 * Math.cos(angleRad) * Math.sin(dirRad) * t;
                    const z = v0 * Math.cos(angleRad) * Math.cos(dirRad) * t;
                    const y = v0 * Math.sin(angleRad) * t - 0.5 * 9.81 * t * t + 1;
                    
                    baseball.position.set(x, Math.max(0, y), z);
                    requestAnimationFrame(update);
                } else {
                    baseball.position.y = 0;
                }
            }
            update();
        }
        
        function determineOutcome(distance, direction) {
            if (distance < 90) return 'out';
            if (distance < 200) return 'single';
            if (distance < 300) return 'double';
            if (distance < 380) return 'triple';
            return 'homerun';
        }
        
        function processPlay(outcome) {
            const currentTeam = gameState.topBottom === 'top' ? 'away' : 'home';
            
            switch(outcome) {
                case 'homerun':
                    if (currentTeam === 'home') {
                        gameState.homeScore += 1;
                        gameState.momentum = Math.min(90, gameState.momentum + 20);
                    } else {
                        gameState.awayScore += 1;
                        gameState.momentum = Math.max(10, gameState.momentum - 20);
                    }
                    break;
                case 'out':
                    gameState.outs += 1;
                    if (gameState.outs >= 3) {
                        switchInning();
                    }
                    break;
            }
            updateUI();
        }
        
        function switchInning() {
            gameState.outs = 0;
            if (gameState.topBottom === 'top') {
                gameState.topBottom = 'bottom';
            } else {
                gameState.topBottom = 'top';
                gameState.inning += 1;
            }
        }
        
        function updateUI() {
            document.getElementById('home-score').textContent = gameState.homeScore;
            document.getElementById('away-score').textContent = gameState.awayScore;
            document.getElementById('inning').textContent = gameState.inning;
            document.getElementById('half').textContent = gameState.topBottom.toUpperCase();
            document.getElementById('momentum').style.width = `${gameState.momentum}%`;
        }
        
        function showCommentary(text) {
            const commentary = document.getElementById('commentary');
            commentary.textContent = text;
            commentary.classList.add('active');
            setTimeout(() => commentary.classList.remove('active'), 5000);
        }
        
        function createFireworks() {
            const particles = new THREE.Group();
            for (let i = 0; i < 50; i++) {
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(Math.random(), Math.random(), Math.random())
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    Math.random() * 100 - 50,
                    Math.random() * 50 + 50,
                    Math.random() * 100 - 50
                );
                particles.add(particle);
            }
            scene.add(particles);
            
            let frame = 0;
            function animateFireworks() {
                frame++;
                particles.children.forEach(p => {
                    p.position.y += Math.random() * 2 - 1;
                    p.position.x += Math.random() * 2 - 1;
                    p.position.z += Math.random() * 2 - 1;
                });
                if (frame < 60) {
                    requestAnimationFrame(animateFireworks);
                } else {
                    scene.remove(particles);
                }
            }
            animateFireworks();
        }
        
        function setCamera(cameraName) {
            currentCamera = cameraName;
            camera = cameras[cameraName];
            document.querySelectorAll('.camera-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        function simulatePitch() {
            baseball.position.set(0, 1, 18.44);
            const endPos = { x: Math.random() * 2 - 1, y: Math.random() * 2 + 0.5, z: 0 };
            animateBall({ x: 0, y: 1, z: 18.44 }, endPos, 500);
        }
        
        function animateBall(start, end, duration) {
            const startTime = Date.now();
            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                baseball.position.x = start.x + (end.x - start.x) * progress;
                baseball.position.y = start.y + (end.y - start.y) * progress;
                baseball.position.z = start.z + (end.z - start.z) * progress;
                if (progress < 1) requestAnimationFrame(update);
            }
            update();
        }
        
        function resetGame() {
            gameState = {
                homeScore: 0, awayScore: 0, inning: 1, topBottom: 'top',
                outs: 0, momentum: 50, currentBatter: 'Rodriguez'
            };
            baseball.position.set(0, 1, 18.44);
            updateUI();
            document.getElementById('current-batter').textContent = gameState.currentBatter;
            generatePlayerNarrative();
            analyzePlayer();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (baseball) baseball.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            Object.values(cameras).forEach(cam => {
                cam.aspect = window.innerWidth / window.innerHeight;
                cam.updateProjectionMatrix();
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        window.addEventListener('load', initScene);
    </script>
</body>
</html>