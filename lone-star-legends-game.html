<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lone Star Legends Championship</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
            font-weight: bold;
        }

        .scoreboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            min-width: 200px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .score-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .team-name {
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .score-number {
            color: #90EE90;
            font-size: 24px;
            font-weight: bold;
        }

        .game-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .inning {
            color: #FFD700;
            font-size: 20px;
            margin-bottom: 15px;
        }

        .count {
            color: #90EE90;
            font-size: 16px;
            line-height: 1.5;
        }

        .controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            font-size: 14px;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .control-tip {
            color: #90EE90;
            margin: 5px 0;
        }

        .control-key {
            color: #FFD700;
            font-weight: bold;
        }

        .power-meter {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 15px;
            display: none;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .power-fill {
            position: absolute;
            bottom: 3px;
            left: 3px;
            right: 3px;
            background: linear-gradient(to top, #00FF00, #FFFF00, #FF0000);
            border-radius: 0 0 12px 12px;
            transition: height 0.1s;
            height: 0%;
        }

        .commentary {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 25px;
            padding: 20px 40px;
            font-size: 20px;
            color: #FFD700;
            opacity: 0;
            transition: opacity 0.5s;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            font-weight: bold;
        }

        .commentary.show {
            opacity: 1;
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .tutorial-content {
            background: #1a472a;
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
        }

        .tutorial-title {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 30px;
        }

        .tutorial-section {
            margin: 20px 0;
            text-align: left;
        }

        .tutorial-heading {
            color: #90EE90;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .tutorial-controls {
            color: #CCC;
            line-height: 1.8;
        }

        .tutorial-button {
            background: linear-gradient(45deg, #228B22, #32CD32);
            border: 3px solid #90EE90;
            border-radius: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 20px 10px;
        }

        .tutorial-button:hover {
            background: linear-gradient(45deg, #32CD32, #228B22);
            transform: translateY(-2px);
        }

        .pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .menu-content {
            background: #1a472a;
            border: 4px solid #FFD700;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
        }

        .menu-title {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 30px;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(45deg, #228B22, #32CD32);
            border: 3px solid #90EE90;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: linear-gradient(45deg, #32CD32, #228B22);
            transform: translateY(-2px);
        }

        .phase-indicator {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a472a;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5000;
            flex-direction: column;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #4a7c59;
            border-top: 6px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Lone Star Legends...</div>
        <div style="color: #90EE90; margin-top: 15px; font-size: 16px;">Preparing stadium and players...</div>
    </div>

    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-content">
            <div class="tutorial-title">‚öæ HOW TO PLAY ‚öæ</div>
            
            <div class="tutorial-section">
                <div class="tutorial-heading">üèè BATTING:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">SPACE</strong> - Hold to charge power, release to swing<br>
                    <strong style="color: #FFD700;">WASD</strong> - Move around in batter's box<br>
                    Watch the power meter and time your release!
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">üèÉ BASE RUNNING:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">‚Üë Arrow</strong> - Advance to next base<br>
                    <strong style="color: #FFD700;">‚Üì Arrow</strong> - Retreat to previous base<br>
                    <strong style="color: #FFD700;">SHIFT</strong> - Sprint (hold while running)
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">ü•é FIELDING:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">WASD</strong> - Move fielder<br>
                    <strong style="color: #FFD700;">SPACE</strong> - Catch/Throw ball<br>
                    <strong style="color: #FFD700;">1,2,3,4</strong> - Quick throw to bases
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">üéÆ GAME CONTROLS:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">ESC</strong> - Pause menu<br>
                    <strong style="color: #FFD700;">P</strong> - Quick pause
                </div>
            </div>

            <button class="tutorial-button" onclick="startGame()">‚öæ PLAY BALL!</button>
            <button class="tutorial-button" onclick="skipTutorial()">Skip Tutorial</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div class="game-hud">
        <div class="scoreboard">
            <div class="score-line">
                <span class="team-name">VISITORS</span>
                <span class="score-number" id="awayScore">0</span>
            </div>
            <div class="score-line">
                <span class="team-name">LEGENDS</span>
                <span class="score-number" id="homeScore">0</span>
            </div>
        </div>

        <div class="game-info">
            <div class="inning">
                <span id="inningHalf">TOP</span> <span id="inning">1</span>
            </div>
            <div class="count">
                <div>Balls: <span id="balls">0</span></div>
                <div>Strikes: <span id="strikes">0</span></div>
                <div>Outs: <span id="outs">0</span></div>
            </div>
        </div>

        <div class="phase-indicator" id="phaseIndicator">
            BATTING
        </div>

        <div class="controls-help">
            <div class="control-tip">
                <span class="control-key">SPACE</span> - Hold to swing
            </div>
            <div class="control-tip">
                <span class="control-key">WASD</span> - Move batter
            </div>
            <div class="control-tip">
                <span class="control-key">ESC</span> - Pause menu
            </div>
            <div class="control-tip" id="dynamicTip">
                Get ready to bat!
            </div>
        </div>

        <div class="power-meter" id="powerMeter">
            <div class="power-fill" id="powerFill"></div>
        </div>

        <div class="commentary" id="commentary"></div>
    </div>

    <div class="pause-menu" id="pauseMenu">
        <div class="menu-content">
            <div class="menu-title">‚öæ PAUSED ‚öæ</div>
            <button class="menu-button" onclick="resumeGame()">Resume Game</button>
            <button class="menu-button" onclick="restartGame()">Restart Game</button>
            <button class="menu-button" onclick="showTutorial()">Show Tutorial</button>
            <button class="menu-button" onclick="quitToMenu()">Quit to Menu</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class LoneStarLegendsGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });

                // Game state
                this.gameState = {
                    homeScore: 0,
                    awayScore: 0,
                    inning: 1,
                    isTopInning: true,
                    outs: 0,
                    balls: 0,
                    strikes: 0,
                    currentPhase: 'batting', // batting, running, fielding, pitching
                    isPaused: false,
                    gameStarted: false,
                    basesLoaded: [false, false, false] // 1st, 2nd, 3rd base
                };

                // Player control
                this.player = {
                    position: new THREE.Vector3(0, 0, 0),
                    battingPosition: new THREE.Vector3(-1, 0, 18)
                };

                // Input handling
                this.keys = {};
                this.powerMeter = 0;
                this.isChargingPower = false;
                this.maxPowerTime = 2000; // 2 seconds for full power

                // Game objects
                this.ball = null;
                this.bat = null;
                this.players = {
                    batter: null,
                    pitcher: null,
                    fielders: [],
                    runners: []
                };

                // Base running system
                this.basePositions = {
                    home: new THREE.Vector3(0, 0.1, 18.44),
                    first: new THREE.Vector3(18.44, 0.1, 0),
                    second: new THREE.Vector3(0, 0.1, -18.44),
                    third: new THREE.Vector3(-18.44, 0.1, 0)
                };

                this.activeRunner = null;
                this.runnerSpeed = 0.3;
                this.sprintMultiplier = 1.8;
                this.selectedFielder = null;

                // Physics
                this.ballPhysics = {
                    position: new THREE.Vector3(0, 1, -18),
                    velocity: new THREE.Vector3(0, 0, 0),
                    inPlay: false,
                    hasBeenHit: false,
                    isThrown: false
                };

                // Audio context (for potential future sounds)
                this.audioContext = null;
                this.sounds = {};

                this.init();
            }

            async init() {
                try {
                    this.setupRenderer();
                    this.setupLighting();
                    this.createStadium();
                    this.createPlayers();
                    this.createBall();
                    this.setupCamera();
                    this.setupInput();
                    
                    // Hide loading screen
                    document.getElementById('loadingScreen').style.display = 'none';
                    
                    // Show tutorial
                    document.getElementById('tutorialOverlay').style.display = 'flex';
                    
                    this.animate();
                } catch (error) {
                    console.error('Failed to initialize game:', error);
                    this.showError('Failed to load game. Please refresh and try again.');
                }
            }

            showError(message) {
                document.getElementById('loadingScreen').innerHTML = `
                    <div style="color: #FF4444; font-size: 24px; text-align: center;">
                        <div>‚ùå Error</div>
                        <div style="font-size: 18px; margin-top: 20px;">${message}</div>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 15px 30px; font-size: 16px; background: #228B22; color: white; border: none; border-radius: 10px; cursor: pointer;">
                            Reload Game
                        </button>
                    </div>
                `;
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB); // Sky blue
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            setupLighting() {
                // Ambient lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // Stadium flood lights
                const lights = [
                    { pos: [80, 100, 40], intensity: 1.5 },
                    { pos: [-80, 100, 40], intensity: 1.5 },
                    { pos: [40, 100, -80], intensity: 1.2 },
                    { pos: [-40, 100, -80], intensity: 1.2 }
                ];

                lights.forEach(light => {
                    const spotLight = new THREE.SpotLight(0xffffff, light.intensity);
                    spotLight.position.set(...light.pos);
                    spotLight.angle = Math.PI / 3;
                    spotLight.penumbra = 0.2;
                    spotLight.decay = 2;
                    spotLight.distance = 400;
                    spotLight.castShadow = true;
                    spotLight.shadow.mapSize.width = 1024;
                    spotLight.shadow.mapSize.height = 1024;
                    this.scene.add(spotLight);
                });

                // Sun light
                const sunLight = new THREE.DirectionalLight(0xfffacd, 0.8);
                sunLight.position.set(200, 300, 100);
                sunLight.castShadow = true;
                sunLight.shadow.camera.near = 1;
                sunLight.shadow.camera.far = 500;
                sunLight.shadow.camera.left = -150;
                sunLight.shadow.camera.right = 150;
                sunLight.shadow.camera.top = 150;
                sunLight.shadow.camera.bottom = -150;
                this.scene.add(sunLight);
            }

            createStadium() {
                // Field grass (smaller for better performance)
                const fieldGeometry = new THREE.PlaneGeometry(300, 300);
                const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                field.rotation.x = -Math.PI / 2;
                field.receiveShadow = true;
                this.scene.add(field);

                // Infield dirt
                const infieldGeometry = new THREE.RingGeometry(0, 30, 4, 1);
                const infieldMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
                const infield = new THREE.Mesh(infieldGeometry, infieldMaterial);
                infield.rotation.x = -Math.PI / 2;
                infield.rotation.z = Math.PI / 4;
                infield.position.y = 0.01;
                infield.receiveShadow = true;
                this.scene.add(infield);

                // Pitcher's mound
                const moundGeometry = new THREE.CylinderGeometry(3, 4, 0.8, 16);
                const moundMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
                const mound = new THREE.Mesh(moundGeometry, moundMaterial);
                mound.position.set(0, 0.4, -18.44);
                mound.castShadow = true;
                mound.receiveShadow = true;
                this.scene.add(mound);

                // Create bases
                this.createBases();

                // Stadium walls (simpler geometry)
                this.createStadiumWalls();

                // Home plate
                const plateGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 5);
                const plateMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                plate.position.set(0, 0.05, 18.44);
                this.scene.add(plate);
            }

            createBases() {
                const baseGeometry = new THREE.BoxGeometry(1.5, 0.2, 1.5);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });

                // 90 feet = ~27.4 meters, scaled down for gameplay
                const baseDistance = 18.44;

                // First base
                const firstBase = new THREE.Mesh(baseGeometry, baseMaterial);
                firstBase.position.set(baseDistance, 0.1, 0);
                firstBase.castShadow = true;
                this.scene.add(firstBase);

                // Second base
                const secondBase = new THREE.Mesh(baseGeometry, baseMaterial);
                secondBase.position.set(0, 0.1, -baseDistance);
                secondBase.castShadow = true;
                this.scene.add(secondBase);

                // Third base
                const thirdBase = new THREE.Mesh(baseGeometry, baseMaterial);
                thirdBase.position.set(-baseDistance, 0.1, 0);
                thirdBase.castShadow = true;
                this.scene.add(thirdBase);
            }

            createStadiumWalls() {
                const wallHeight = 12;
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });

                // Outfield walls
                const walls = [
                    { pos: [-80, wallHeight/2, -60], size: [4, wallHeight, 120] }, // Left field
                    { pos: [0, wallHeight/2, -120], size: [160, wallHeight, 4] },   // Center field
                    { pos: [80, wallHeight/2, -60], size: [4, wallHeight, 120] }    // Right field
                ];

                walls.forEach(wall => {
                    const wallGeometry = new THREE.BoxGeometry(...wall.size);
                    const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    wallMesh.receiveShadow = true;
                    this.scene.add(wallMesh);
                });

                // Foul poles
                const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 20);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                
                const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
                leftPole.position.set(-70, 10, -70);
                this.scene.add(leftPole);
                
                const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
                rightPole.position.set(70, 10, -70);
                this.scene.add(rightPole);
            }

            createPlayers() {
                // Create batter
                const batterGeometry = new THREE.CapsuleGeometry(0.8, 3.5);
                const batterMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4444 });
                this.players.batter = new THREE.Mesh(batterGeometry, batterMaterial);
                this.players.batter.position.copy(this.player.battingPosition);
                this.players.batter.position.y = 2;
                this.players.batter.castShadow = true;
                this.scene.add(this.players.batter);

                // Create bat
                const batGeometry = new THREE.CylinderGeometry(0.1, 0.15, 2.5);
                const batMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                this.bat = new THREE.Mesh(batGeometry, batMaterial);
                this.bat.position.set(-2.5, 2.5, 18.44);
                this.bat.rotation.z = Math.PI / 4;
                this.bat.castShadow = true;
                this.scene.add(this.bat);

                // Create pitcher
                const pitcherGeometry = new THREE.CapsuleGeometry(0.8, 3.5);
                const pitcherMaterial = new THREE.MeshLambertMaterial({ color: 0x4444FF });
                this.players.pitcher = new THREE.Mesh(pitcherGeometry, pitcherMaterial);
                this.players.pitcher.position.set(0, 2, -18.44);
                this.players.pitcher.castShadow = true;
                this.scene.add(this.players.pitcher);

                // Create fielders (simplified positions)
                const fielderPositions = [
                    [18, 2, 5],    // 1B
                    [12, 2, -8],   // 2B
                    [-18, 2, 5],   // 3B
                    [-12, 2, -8],  // SS
                    [-50, 2, -50], // LF
                    [0, 2, -80],   // CF
                    [50, 2, -50],  // RF
                    [0, 2, 22]     // C
                ];

                const fielderGeometry = new THREE.CapsuleGeometry(0.7, 3.2);
                const fielderMaterial = new THREE.MeshLambertMaterial({ color: 0x4444FF });

                fielderPositions.forEach(pos => {
                    const fielder = new THREE.Mesh(fielderGeometry, fielderMaterial);
                    fielder.position.set(...pos);
                    fielder.castShadow = true;
                    
                    // Initialize fielder userData
                    fielder.userData = {
                        selected: false,
                        originalPosition: new THREE.Vector3(...pos)
                    };
                    
                    this.players.fielders.push(fielder);
                    this.scene.add(fielder);
                });
            }

            createBall() {
                const ballGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                this.ball = new THREE.Mesh(ballGeometry, ballMaterial);
                this.ball.position.copy(this.ballPhysics.position);
                this.ball.castShadow = true;
                this.scene.add(this.ball);
            }

            setupCamera() {
                // Behind home plate camera angle
                this.camera.position.set(0, 10, 30);
                this.camera.lookAt(0, 2, -18);
            }

            setupInput() {
                document.addEventListener('keydown', (event) => {
                    this.keys[event.code] = true;
                    this.handleKeyDown(event);
                });

                document.addEventListener('keyup', (event) => {
                    this.keys[event.code] = false;
                    this.handleKeyUp(event);
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Prevent context menu on right click
                document.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }

            handleKeyDown(event) {
                if (!this.gameState.gameStarted || this.gameState.isPaused) return;

                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'batting') {
                            if (!this.isChargingPower) {
                                this.startPowerCharge();
                            }
                        } else if (this.gameState.currentPhase === 'fielding' && this.selectedFielder) {
                            this.throwBall();
                        }
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.advanceRunner();
                        }
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.retreatRunner();
                        }
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.selectPreviousRunner();
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.selectNextRunner();
                        }
                        break;
                    case 'Digit1':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('home');
                        }
                        break;
                    case 'Digit2':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('first');
                        }
                        break;
                    case 'Digit3':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('second');
                        }
                        break;
                    case 'Digit4':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('third');
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.togglePauseMenu();
                        break;
                    case 'KeyP':
                        event.preventDefault();
                        this.togglePause();
                        break;
                }
            }

            handleKeyUp(event) {
                if (!this.gameState.gameStarted || this.gameState.isPaused) return;

                switch(event.code) {
                    case 'Space':
                        if (this.gameState.currentPhase === 'batting' && this.isChargingPower) {
                            this.swing();
                        }
                        break;
                }
            }

            updatePlayerMovement() {
                if (!this.gameState.gameStarted || this.gameState.isPaused) return;

                const moveSpeed = 0.2;
                const sprintSpeed = (this.keys['ShiftLeft'] || this.keys['ShiftRight']) ? moveSpeed * this.sprintMultiplier : moveSpeed;

                if (this.gameState.currentPhase === 'batting') {
                    // Move in batter's box
                    if (this.keys['KeyW']) {
                        this.players.batter.position.z = Math.max(16, this.players.batter.position.z - moveSpeed);
                    }
                    if (this.keys['KeyS']) {
                        this.players.batter.position.z = Math.min(20, this.players.batter.position.z + moveSpeed);
                    }
                    if (this.keys['KeyA']) {
                        this.players.batter.position.x = Math.max(-3, this.players.batter.position.x - moveSpeed);
                    }
                    if (this.keys['KeyD']) {
                        this.players.batter.position.x = Math.min(1, this.players.batter.position.x + moveSpeed);
                    }
                } else if (this.gameState.currentPhase === 'fielding' && this.selectedFielder) {
                    // Control selected fielder with WASD
                    if (this.keys['KeyW']) {
                        this.selectedFielder.position.z -= sprintSpeed;
                    }
                    if (this.keys['KeyS']) {
                        this.selectedFielder.position.z += sprintSpeed;
                    }
                    if (this.keys['KeyA']) {
                        this.selectedFielder.position.x -= sprintSpeed;
                    }
                    if (this.keys['KeyD']) {
                        this.selectedFielder.position.x += sprintSpeed;
                    }
                }

                // Update runner animations
                this.updateRunnerMovement();
            }

            startPowerCharge() {
                this.isChargingPower = true;
                this.powerMeter = 0;
                this.powerStartTime = Date.now();
                document.getElementById('powerMeter').style.display = 'block';
                
                this.updateDynamicTip('Release SPACE to swing!');
                this.pitchBall();
            }

            updatePowerMeter() {
                if (this.isChargingPower) {
                    const elapsed = Date.now() - this.powerStartTime;
                    this.powerMeter = Math.min(100, (elapsed / this.maxPowerTime) * 100);
                    
                    document.getElementById('powerFill').style.height = this.powerMeter + '%';
                }
            }

            pitchBall() {
                // Reset ball
                this.ballPhysics.position.set(0, 1.5, -18.44);
                this.ballPhysics.velocity.set(0, 0, 0);
                this.ballPhysics.inPlay = true;
                this.ballPhysics.hasBeenHit = false;
                this.ballPhysics.isThrown = false;
                
                // Pitch towards home plate
                const speed = 20 + Math.random() * 8; // Varied speed
                const horizontalVariation = (Math.random() - 0.5) * 2;
                const verticalVariation = (Math.random() - 0.5) * 1.5;
                
                this.ballPhysics.velocity.set(
                    horizontalVariation,
                    verticalVariation,
                    speed
                );

                this.showCommentary("Here comes the pitch!");
                this.animatePitcher();
            }

            swing() {
                this.isChargingPower = false;
                document.getElementById('powerMeter').style.display = 'none';
                
                // Animate bat swing
                this.animateBatSwing();
                
                // Check for contact
                const ballPos = this.ballPhysics.position;
                const batterPos = this.players.batter.position;
                
                // Hit zone calculation
                const hitDistance = ballPos.distanceTo(batterPos);
                const isInStrikeZone = ballPos.z > 15 && ballPos.z < 22 && 
                                     ballPos.y > 0.5 && ballPos.y < 3.5 &&
                                     Math.abs(ballPos.x - batterPos.x) < 2.5;
                
                if (hitDistance < 3.5 && isInStrikeZone && this.ballPhysics.inPlay) {
                    this.hitBall();
                } else {
                    this.strike();
                }
            }

            hitBall() {
                this.ballPhysics.hasBeenHit = true;
                
                // Calculate hit quality based on power and timing
                const power = this.powerMeter / 100;
                const contactQuality = 0.6 + Math.random() * 0.4;
                const totalPower = (power * 0.7 + contactQuality * 0.3);
                
                // Hit direction and elevation
                const angle = (Math.random() - 0.5) * Math.PI * 0.7; // Spread
                const elevation = Math.min(Math.PI / 3, totalPower * Math.PI / 2.5);
                
                const hitSpeed = 15 + totalPower * 35; // 15-50 m/s
                
                this.ballPhysics.velocity.set(
                    Math.sin(angle) * Math.cos(elevation) * hitSpeed,
                    Math.sin(elevation) * hitSpeed,
                    -Math.cos(angle) * Math.cos(elevation) * hitSpeed
                );
                
                // Update game phase
                this.gameState.currentPhase = 'fielding';
                this.updatePhaseIndicator();
                
                const exitVelocity = hitSpeed * 2.237; // Convert to mph
                let hitType = this.determineHitType(exitVelocity, elevation);
                
                // Create a runner on first base (batter becomes runner)
                this.addRunnerOnBase(1);
                
                // Auto-select closest fielder
                this.selectClosestFielder();
                
                this.showCommentary(`${hitType} - ${exitVelocity.toFixed(0)} mph!`);
                this.updateDynamicTip('Ball in play! Control fielders with WASD!');
            }

            determineHitType(velocity, elevation) {
                if (velocity > 105 && elevation > 0.4) return "CRUSHED! Home run potential!";
                if (velocity > 95) return "SMASHED! Deep drive!";
                if (velocity > 85) return "SOLID contact! Line drive!";
                if (elevation < 0.2) return "Ground ball hit!";
                return "Fly ball in the air!";
            }

            strike() {
                this.gameState.strikes++;
                
                if (this.gameState.strikes >= 3) {
                    this.strikeout();
                } else {
                    this.showCommentary(`Strike ${this.gameState.strikes}!`);
                    this.updateDynamicTip(`${this.gameState.strikes} strikes - be careful!`);
                }
                
                this.updateHUD();
                this.resetForNextPitch();
            }

            strikeout() {
                this.gameState.outs++;
                this.showCommentary("Strike three! You're out!");
                this.updateDynamicTip("Strikeout! Next batter up.");
                
                if (this.gameState.outs >= 3) {
                    this.endInning();
                } else {
                    this.nextBatter();
                }
            }

            nextBatter() {
                this.gameState.balls = 0;
                this.gameState.strikes = 0;
                this.gameState.currentPhase = 'batting';
                
                this.players.batter.position.copy(this.player.battingPosition);
                this.players.batter.position.y = 2;
                
                this.updateHUD();
                this.updatePhaseIndicator();
                this.updateDynamicTip("New batter - get ready!");
                this.resetForNextPitch();
            }

            endInning() {
                this.gameState.outs = 0;
                this.gameState.isTopInning = !this.gameState.isTopInning;
                
                if (!this.gameState.isTopInning) {
                    this.gameState.inning++;
                }
                
                this.showCommentary(`End of the ${this.gameState.isTopInning ? 'bottom' : 'top'} of the ${this.gameState.inning}!`);
                this.nextBatter();
            }

            resetForNextPitch() {
                this.ballPhysics.inPlay = false;
                this.ballPhysics.position.set(0, 1.5, -18.44);
                this.ballPhysics.velocity.set(0, 0, 0);
                this.ball.position.copy(this.ballPhysics.position);
            }

            updateBallPhysics() {
                if (!this.ballPhysics.inPlay) return;
                
                const deltaTime = 0.016; // 60fps
                
                // Update position
                this.ballPhysics.position.add(
                    this.ballPhysics.velocity.clone().multiplyScalar(deltaTime)
                );
                
                // Apply gravity
                this.ballPhysics.velocity.y -= 9.8 * deltaTime;
                
                // Ground collision
                if (this.ballPhysics.position.y <= 0.15) {
                    this.ballPhysics.position.y = 0.15;
                    this.ballPhysics.velocity.y = Math.abs(this.ballPhysics.velocity.y) * 0.4;
                    this.ballPhysics.velocity.x *= 0.7;
                    this.ballPhysics.velocity.z *= 0.7;
                    
                    if (Math.abs(this.ballPhysics.velocity.y) < 0.1) {
                        this.ballPhysics.velocity.y = 0;
                    }
                }
                
                // Update visual ball
                this.ball.position.copy(this.ballPhysics.position);
                
                // Check for player catch attempt
                if (this.gameState.currentPhase === 'fielding' && this.selectedFielder) {
                    this.attemptCatch();
                }
                
                // Update fielder AI
                this.updateFielderAI();
                
                // Check for home run
                this.checkHomeRun();
                
                // Check if ball is out of play
                if (Math.abs(this.ballPhysics.position.x) > 150 || 
                    Math.abs(this.ballPhysics.position.z) > 150) {
                    this.ballOutOfPlay();
                }
            }

            checkHomeRun() {
                const ballPos = this.ballPhysics.position;
                
                // Check if ball cleared the wall
                if (ballPos.z < -110 && ballPos.y > 10) {
                    this.homeRun();
                }
            }

            homeRun() {
                this.gameState.homeScore++;
                this.showCommentary("üéâ HOME RUN! IT'S OUTTA HERE! üéâ");
                this.updateDynamicTip("HOME RUN! Amazing!");
                
                this.ballPhysics.inPlay = false;
                this.nextBatter();
                this.updateHUD();
            }

            ballOutOfPlay() {
                this.ballPhysics.inPlay = false;
                this.gameState.currentPhase = 'batting';
                this.updatePhaseIndicator();
                this.updateDynamicTip("Ball is out of play - next pitch!");
                this.resetForNextPitch();
            }

            animateBatSwing() {
                const originalRotation = this.bat.rotation.z;
                const originalPosition = this.bat.position.x;
                
                // Quick swing animation
                this.bat.rotation.z = -Math.PI / 6;
                this.bat.position.x -= 0.8;
                
                setTimeout(() => {
                    this.bat.rotation.z = originalRotation;
                    this.bat.position.x = originalPosition;
                }, 250);
            }

            animatePitcher() {
                const originalY = this.players.pitcher.position.y;
                const originalRotation = this.players.pitcher.rotation.x;
                
                // Wind up
                this.players.pitcher.rotation.x = -0.2;
                this.players.pitcher.position.y = originalY - 0.3;
                
                setTimeout(() => {
                    // Follow through
                    this.players.pitcher.rotation.x = 0.2;
                }, 300);
                
                setTimeout(() => {
                    // Return to normal
                    this.players.pitcher.rotation.x = originalRotation;
                    this.players.pitcher.position.y = originalY;
                }, 800);
            }

            // === BASE RUNNING SYSTEM ===
            
            createRunner(baseNumber = 0) {
                // Create a visual runner
                const runnerGeometry = new THREE.CapsuleGeometry(0.4, 1.8);
                const runnerMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
                
                // Position runner at base
                if (baseNumber === 0) {
                    runner.position.copy(this.basePositions.home);
                } else if (baseNumber === 1) {
                    runner.position.copy(this.basePositions.first);
                } else if (baseNumber === 2) {
                    runner.position.copy(this.basePositions.second);
                } else if (baseNumber === 3) {
                    runner.position.copy(this.basePositions.third);
                }
                
                runner.position.y = 1;
                runner.castShadow = true;
                
                runner.userData = {
                    currentBase: baseNumber,
                    targetBase: baseNumber,
                    isMoving: false,
                    moveProgress: 0,
                    selected: false
                };
                
                this.scene.add(runner);
                this.players.runners.push(runner);
                
                // Update base status
                if (baseNumber > 0) {
                    this.gameState.basesLoaded[baseNumber - 1] = true;
                }
                
                return runner;
            }

            addRunnerOnBase(baseNumber) {
                // Check if base already occupied
                if (baseNumber === 1 && this.gameState.basesLoaded[0]) return;
                if (baseNumber === 2 && this.gameState.basesLoaded[1]) return;
                if (baseNumber === 3 && this.gameState.basesLoaded[2]) return;
                
                const runner = this.createRunner(baseNumber);
                
                // Make this the active runner
                this.selectRunner(runner);
                
                this.showCommentary(`Runner on ${this.getBaseName(baseNumber)}!`);
                this.gameState.currentPhase = 'running';
                this.updatePhaseIndicator();
                this.updateDynamicTip('Use arrow keys to control runner!');
            }

            getBaseName(baseNumber) {
                const baseNames = ['Home', 'First', 'Second', 'Third'];
                return baseNames[baseNumber] || 'Unknown';
            }

            selectRunner(runner) {
                // Deselect all runners
                this.players.runners.forEach(r => {
                    r.userData.selected = false;
                    r.material.color.setHex(0xFF0000); // Red
                });
                
                // Select new runner
                if (runner) {
                    this.activeRunner = runner;
                    runner.userData.selected = true;
                    runner.material.color.setHex(0xFFD700); // Gold
                }
            }

            selectNextRunner() {
                if (this.players.runners.length === 0) return;
                
                let currentIndex = this.players.runners.indexOf(this.activeRunner);
                currentIndex = (currentIndex + 1) % this.players.runners.length;
                this.selectRunner(this.players.runners[currentIndex]);
                
                const baseName = this.getBaseName(this.activeRunner.userData.currentBase);
                this.updateDynamicTip(`Selected runner on ${baseName}`);
            }

            selectPreviousRunner() {
                if (this.players.runners.length === 0) return;
                
                let currentIndex = this.players.runners.indexOf(this.activeRunner);
                currentIndex = (currentIndex - 1 + this.players.runners.length) % this.players.runners.length;
                this.selectRunner(this.players.runners[currentIndex]);
                
                const baseName = this.getBaseName(this.activeRunner.userData.currentBase);
                this.updateDynamicTip(`Selected runner on ${baseName}`);
            }

            advanceRunner() {
                if (!this.activeRunner || this.activeRunner.userData.isMoving) return;
                
                const currentBase = this.activeRunner.userData.currentBase;
                const nextBase = (currentBase + 1) % 4;
                
                // Check if next base is occupied
                if (nextBase > 0 && nextBase < 4 && this.gameState.basesLoaded[nextBase - 1]) {
                    this.updateDynamicTip(`${this.getBaseName(nextBase)} is occupied!`);
                    return;
                }
                
                this.moveRunnerToBase(this.activeRunner, nextBase);
            }

            retreatRunner() {
                if (!this.activeRunner || this.activeRunner.userData.isMoving) return;
                
                const currentBase = this.activeRunner.userData.currentBase;
                if (currentBase === 0) return; // Can't retreat from home
                
                const prevBase = currentBase - 1;
                
                // Check if previous base is occupied
                if (prevBase > 0 && this.gameState.basesLoaded[prevBase - 1]) {
                    this.updateDynamicTip(`${this.getBaseName(prevBase)} is occupied!`);
                    return;
                }
                
                this.moveRunnerToBase(this.activeRunner, prevBase);
            }

            moveRunnerToBase(runner, targetBase) {
                if (!runner || runner.userData.isMoving) return;
                
                const currentBase = runner.userData.currentBase;
                
                // Clear current base
                if (currentBase > 0) {
                    this.gameState.basesLoaded[currentBase - 1] = false;
                }
                
                runner.userData.targetBase = targetBase;
                runner.userData.isMoving = true;
                runner.userData.moveProgress = 0;
                
                const baseName = this.getBaseName(targetBase);
                this.showCommentary(`Running to ${baseName}!`);
                
                // Check for scoring
                if (targetBase === 0) {
                    this.showCommentary('RUNNER SCORES!');
                    this.gameState.homeScore++;
                    this.updateHUD();
                }
            }

            updateRunnerMovement() {
                this.players.runners.forEach(runner => {
                    if (!runner.userData.isMoving) return;
                    
                    const speed = this.runnerSpeed;
                    runner.userData.moveProgress += speed;
                    
                    if (runner.userData.moveProgress >= 1.0) {
                        // Reached target base
                        runner.userData.moveProgress = 1.0;
                        runner.userData.isMoving = false;
                        runner.userData.currentBase = runner.userData.targetBase;
                        
                        // Update base status
                        if (runner.userData.currentBase > 0 && runner.userData.currentBase < 4) {
                            this.gameState.basesLoaded[runner.userData.currentBase - 1] = true;
                        }
                        
                        // Remove runner if they reached home
                        if (runner.userData.currentBase === 0) {
                            this.scene.remove(runner);
                            const index = this.players.runners.indexOf(runner);
                            this.players.runners.splice(index, 1);
                            
                            // Select next runner if needed
                            if (this.activeRunner === runner && this.players.runners.length > 0) {
                                this.selectRunner(this.players.runners[0]);
                            } else if (this.players.runners.length === 0) {
                                this.activeRunner = null;
                                this.gameState.currentPhase = 'batting';
                                this.updatePhaseIndicator();
                                this.updateDynamicTip('Get ready for the next batter!');
                            }
                        }
                    } else {
                        // Interpolate position
                        const currentPos = this.getBasePosition(runner.userData.currentBase);
                        const targetPos = this.getBasePosition(runner.userData.targetBase);
                        
                        runner.position.lerpVectors(currentPos, targetPos, runner.userData.moveProgress);
                        runner.position.y = 1; // Keep runner at ground level
                    }
                });
            }

            getBasePosition(baseNumber) {
                switch(baseNumber) {
                    case 0: return this.basePositions.home.clone();
                    case 1: return this.basePositions.first.clone();
                    case 2: return this.basePositions.second.clone();
                    case 3: return this.basePositions.third.clone();
                    default: return this.basePositions.home.clone();
                }
            }

            // === FIELDING SYSTEM ===
            
            throwToBase(baseName) {
                if (!this.selectedFielder) {
                    this.selectClosestFielder();
                    return;
                }
                
                // Calculate throw trajectory and speed
                const throwSpeed = 25; // m/s
                const targetPosition = this.basePositions[baseName].clone();
                targetPosition.y = 1.5; // Chest height
                
                const direction = targetPosition.clone().sub(this.selectedFielder.position).normalize();
                
                // Reset ball position to fielder
                this.ballPhysics.position.copy(this.selectedFielder.position);
                this.ballPhysics.position.y += 1.5; // Throwing height
                
                // Set ball velocity towards base
                this.ballPhysics.velocity.copy(direction.multiplyScalar(throwSpeed));
                this.ballPhysics.inPlay = true;
                this.ballPhysics.hasBeenHit = false;
                this.ballPhysics.isThrown = true;
                
                this.showCommentary(`Throwing to ${baseName}!`);
                this.updateDynamicTip('Ball thrown - watch the play!');
                
                // Animate fielder throw
                this.animateFielderThrow(this.selectedFielder);
            }

            selectClosestFielder() {
                if (this.players.fielders.length === 0) return;
                
                // Find fielder closest to ball
                let closestFielder = null;
                let closestDistance = Infinity;
                
                this.players.fielders.forEach(fielder => {
                    const distance = fielder.position.distanceTo(this.ballPhysics.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestFielder = fielder;
                    }
                });
                
                if (closestFielder) {
                    this.selectFielder(closestFielder);
                }
            }

            selectFielder(fielder) {
                // Deselect all fielders
                this.players.fielders.forEach(f => {
                    f.material.color.setHex(0x0000FF); // Blue
                    f.userData.selected = false;
                });
                
                // Select new fielder
                this.selectedFielder = fielder;
                fielder.material.color.setHex(0xFFD700); // Gold
                fielder.userData.selected = true;
                
                this.updateDynamicTip('Control fielder with WASD, SPACE to throw');
            }

            attemptCatch() {
                if (!this.selectedFielder || !this.ballPhysics.inPlay) return false;
                
                const ballPos = new THREE.Vector3().copy(this.ballPhysics.position);
                const fielderPos = this.selectedFielder.position.clone();
                fielderPos.y += 1; // Fielder reach height
                
                const catchRadius = 2.5; // Catching range
                const distance = ballPos.distanceTo(fielderPos);
                
                if (distance <= catchRadius && ballPos.y <= 3 && ballPos.y >= 0.2) {
                    // Successful catch!
                    this.ballPhysics.inPlay = false;
                    this.ballPhysics.velocity.set(0, 0, 0);
                    
                    // Position ball in fielder's glove
                    this.ballPhysics.position.copy(fielderPos);
                    
                    this.showCommentary('CAUGHT! Great defensive play!');
                    this.updateDynamicTip('Ball caught! Press 1-4 to throw to bases');
                    
                    // Animate catch
                    this.animateFielderCatch(this.selectedFielder);
                    
                    // Update game state
                    this.gameState.outs++;
                    this.updateHUD();
                    
                    if (this.gameState.outs >= 3) {
                        this.endInning();
                    }
                    
                    return true;
                }
                
                return false;
            }

            updateFielderAI() {
                if (!this.ballPhysics.inPlay || this.ballPhysics.isThrown) return;
                
                this.players.fielders.forEach(fielder => {
                    if (fielder === this.selectedFielder) return; // Don't AI-control selected fielder
                    
                    const ballPos = new THREE.Vector3().copy(this.ballPhysics.position);
                    const fielderPos = fielder.position;
                    const distance = fielderPos.distanceTo(ballPos);
                    
                    // Only move if ball is relatively close and in the air or bouncing
                    if (distance < 30 && ballPos.y > 0.5) {
                        const direction = ballPos.clone().sub(fielderPos).normalize();
                        const moveSpeed = 0.15;
                        
                        // Move towards ball but don't overshoot
                        if (distance > 2) {
                            fielder.position.add(direction.multiplyScalar(moveSpeed));
                        }
                        
                        // Attempt automatic catch for AI fielders
                        const catchRadius = 2.0;
                        if (distance <= catchRadius && ballPos.y <= 3 && ballPos.y >= 0.2) {
                            this.ballPhysics.inPlay = false;
                            this.ballPhysics.velocity.set(0, 0, 0);
                            this.ballPhysics.position.copy(fielder.position);
                            this.ballPhysics.position.y = 1.5;
                            
                            this.showCommentary('Fielder makes the catch!');
                            this.selectFielder(fielder);
                            this.updateDynamicTip('Ball caught by AI fielder! Take control with WASD');
                            
                            this.gameState.outs++;
                            this.updateHUD();
                            
                            if (this.gameState.outs >= 3) {
                                this.endInning();
                            }
                        }
                    }
                });
            }

            animateFielderCatch(fielder) {
                const originalY = fielder.position.y;
                const originalScale = fielder.scale.y;
                
                // Jump slightly for catch
                fielder.position.y = originalY + 0.3;
                fielder.scale.y = originalScale * 1.1;
                
                setTimeout(() => {
                    fielder.position.y = originalY;
                    fielder.scale.y = originalScale;
                }, 300);
            }

            animateFielderThrow(fielder) {
                const originalRotation = fielder.rotation.z;
                
                // Throwing motion
                fielder.rotation.z = Math.PI / 6;
                
                setTimeout(() => {
                    fielder.rotation.z = -Math.PI / 6;
                }, 150);
                
                setTimeout(() => {
                    fielder.rotation.z = originalRotation;
                }, 400);
            }

            showCommentary(text) {
                const commentary = document.getElementById('commentary');
                commentary.textContent = text;
                commentary.classList.add('show');
                
                setTimeout(() => {
                    commentary.classList.remove('show');
                }, 3000);
            }

            updatePhaseIndicator() {
                const indicator = document.getElementById('phaseIndicator');
                const phases = {
                    'batting': 'BATTING',
                    'fielding': 'FIELDING',
                    'running': 'RUNNING'
                };
                indicator.textContent = phases[this.gameState.currentPhase] || 'PLAYING';
            }

            updateDynamicTip(text) {
                document.getElementById('dynamicTip').textContent = text;
            }

            updateHUD() {
                document.getElementById('homeScore').textContent = this.gameState.homeScore;
                document.getElementById('awayScore').textContent = this.gameState.awayScore;
                document.getElementById('inning').textContent = this.gameState.inning;
                document.getElementById('inningHalf').textContent = this.gameState.isTopInning ? 'TOP' : 'BOT';
                document.getElementById('balls').textContent = this.gameState.balls;
                document.getElementById('strikes').textContent = this.gameState.strikes;
                document.getElementById('outs').textContent = this.gameState.outs;
            }

            togglePauseMenu() {
                const menu = document.getElementById('pauseMenu');
                if (menu.style.display === 'flex') {
                    menu.style.display = 'none';
                    this.gameState.isPaused = false;
                } else {
                    menu.style.display = 'flex';
                    this.gameState.isPaused = true;
                }
            }

            togglePause() {
                this.gameState.isPaused = !this.gameState.isPaused;
                this.showCommentary(this.gameState.isPaused ? "‚è∏Ô∏è Game Paused" : "‚ñ∂Ô∏è Game Resumed");
            }

            startNewGame() {
                this.gameState = {
                    homeScore: 0,
                    awayScore: 0,
                    inning: 1,
                    isTopInning: true,
                    outs: 0,
                    balls: 0,
                    strikes: 0,
                    currentPhase: 'batting',
                    isPaused: false,
                    gameStarted: true
                };
                
                this.players.batter.position.copy(this.player.battingPosition);
                this.players.batter.position.y = 2;
                
                this.resetForNextPitch();
                this.updateHUD();
                this.updatePhaseIndicator();
                this.updateDynamicTip("Play ball! Hold SPACE to charge your swing!");
                
                this.showCommentary("‚öæ PLAY BALL! Welcome to Lone Star Legends! ‚öæ");
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.gameState.gameStarted && !this.gameState.isPaused) {
                    this.updatePlayerMovement();
                    this.updatePowerMeter();
                    this.updateBallPhysics();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Global game instance
        let game;

        // Global control functions
        function startGame() {
            document.getElementById('tutorialOverlay').style.display = 'none';
            if (game) {
                game.startNewGame();
            }
        }

        function skipTutorial() {
            startGame();
        }

        function resumeGame() {
            document.getElementById('pauseMenu').style.display = 'none';
            if (game) game.gameState.isPaused = false;
        }

        function restartGame() {
            if (game) {
                game.startNewGame();
                resumeGame();
            }
        }

        function showTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'flex';
            resumeGame();
        }

        function quitToMenu() {
            if (confirm("Return to main menu?")) {
                window.location.href = 'index.html';
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            game = new LoneStarLegendsGame();
        });

        // Prevent accidental page refresh
        window.addEventListener('beforeunload', (event) => {
            if (game && game.gameState.gameStarted) {
                event.preventDefault();
                event.returnValue = '';
            }
        });
    </script>
</body>
</html>