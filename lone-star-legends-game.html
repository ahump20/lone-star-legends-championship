<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lone Star Legends Championship</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', Arial, sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
            font-weight: bold;
        }

        .scoreboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            min-width: 200px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .score-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .team-name {
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .score-number {
            color: #90EE90;
            font-size: 24px;
            font-weight: bold;
        }

        .game-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .inning {
            color: #FFD700;
            font-size: 20px;
            margin-bottom: 15px;
        }

        .count {
            color: #90EE90;
            font-size: 16px;
            line-height: 1.5;
        }

        .controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            font-size: 14px;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .control-tip {
            color: #90EE90;
            margin: 5px 0;
        }

        .control-key {
            color: #FFD700;
            font-weight: bold;
        }

        .power-meter {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            border-radius: 15px;
            display: none;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .power-fill {
            position: absolute;
            bottom: 3px;
            left: 3px;
            right: 3px;
            background: linear-gradient(to top, #00FF00, #FFFF00, #FF0000);
            border-radius: 0 0 12px 12px;
            transition: height 0.1s;
            height: 0%;
        }

        .commentary {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 25px;
            padding: 20px 40px;
            font-size: 20px;
            color: #FFD700;
            opacity: 0;
            transition: opacity 0.5s;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            font-weight: bold;
        }

        .commentary.show {
            opacity: 1;
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .tutorial-content {
            background: #1a472a;
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
        }

        .tutorial-title {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 30px;
        }

        .tutorial-section {
            margin: 20px 0;
            text-align: left;
        }

        .tutorial-heading {
            color: #90EE90;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .tutorial-controls {
            color: #CCC;
            line-height: 1.8;
        }

        .tutorial-button {
            background: linear-gradient(45deg, #228B22, #32CD32);
            border: 3px solid #90EE90;
            border-radius: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 20px 10px;
        }

        .tutorial-button:hover {
            background: linear-gradient(45deg, #32CD32, #228B22);
            transform: translateY(-2px);
        }

        .pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .menu-content {
            background: #1a472a;
            border: 4px solid #FFD700;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
        }

        .menu-title {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 30px;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(45deg, #228B22, #32CD32);
            border: 3px solid #90EE90;
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: linear-gradient(45deg, #32CD32, #228B22);
            transform: translateY(-2px);
        }

        .phase-indicator {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a472a;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5000;
            flex-direction: column;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #4a7c59;
            border-top: 6px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Lone Star Legends...</div>
        <div style="color: #90EE90; margin-top: 15px; font-size: 16px;">Preparing stadium and players...</div>
    </div>

    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-content">
            <div class="tutorial-title">‚öæ HOW TO PLAY ‚öæ</div>
            
            <div class="tutorial-section">
                <div class="tutorial-heading">üèè BATTING:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">SPACE</strong> - Hold to charge power, release to swing<br>
                    <strong style="color: #FFD700;">WASD</strong> - Move around in batter's box<br>
                    Watch the power meter and time your release!
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">üèÉ BASE RUNNING:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">‚Üë Arrow</strong> - Advance to next base<br>
                    <strong style="color: #FFD700;">‚Üì Arrow</strong> - Retreat to previous base<br>
                    <strong style="color: #FFD700;">SHIFT</strong> - Sprint (hold while running)
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">ü•é FIELDING:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">WASD</strong> - Move fielder<br>
                    <strong style="color: #FFD700;">SPACE</strong> - Catch/Throw ball<br>
                    <strong style="color: #FFD700;">1,2,3,4</strong> - Quick throw to bases
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">üéÆ GAME CONTROLS:</div>
                <div class="tutorial-controls">
                    <strong style="color: #FFD700;">ESC</strong> - Pause menu<br>
                    <strong style="color: #FFD700;">P</strong> - Quick pause
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-heading">üèüÔ∏è GAME LENGTH:</div>
                <div class="tutorial-controls" style="display: flex; justify-content: space-around; padding: 10px;">
                    <button class="tutorial-button" onclick="setGameLength(3)" style="padding: 10px 20px; margin: 0 5px;">
                        3 Innings
                    </button>
                    <button class="tutorial-button" onclick="setGameLength(6)" style="padding: 10px 20px; margin: 0 5px;">
                        6 Innings
                    </button>
                    <button class="tutorial-button" onclick="setGameLength(9)" style="padding: 10px 20px; margin: 0 5px; background: linear-gradient(45deg, #FFD700, #FFA500);">
                        9 Innings
                    </button>
                </div>
                <div style="text-align: center; color: #90EE90; margin-top: 10px;">
                    Selected: <span id="selectedInnings" style="color: #FFD700;">9</span> innings
                </div>
            </div>

            <button class="tutorial-button" onclick="startGame()">‚öæ PLAY BALL!</button>
            <button class="tutorial-button" onclick="skipTutorial()">Skip Tutorial</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div class="game-hud">
        <div class="scoreboard">
            <div class="score-line">
                <span class="team-name">VISITORS</span>
                <span class="score-number" id="awayScore">0</span>
            </div>
            <div class="score-line">
                <span class="team-name">LEGENDS</span>
                <span class="score-number" id="homeScore">0</span>
            </div>
        </div>

        <div class="game-info">
            <div class="inning">
                <span id="inningHalf">TOP</span> <span id="inning">1</span>
            </div>
            <div class="count">
                <div>Balls: <span id="balls">0</span></div>
                <div>Strikes: <span id="strikes">0</span></div>
                <div>Outs: <span id="outs">0</span></div>
            </div>
        </div>

        <div class="phase-indicator" id="phaseIndicator">
            BATTING
        </div>

        <div class="controls-help">
            <div class="control-tip">
                <span class="control-key">SPACE</span> - Hold to swing
            </div>
            <div class="control-tip">
                <span class="control-key">WASD</span> - Move batter
            </div>
            <div class="control-tip">
                <span class="control-key">ESC</span> - Pause menu
            </div>
            <div class="control-tip" id="dynamicTip">
                Get ready to bat!
            </div>
        </div>

        <div class="power-meter" id="powerMeter">
            <div class="power-fill" id="powerFill"></div>
        </div>

        <div class="commentary" id="commentary"></div>
    </div>

    <div class="pause-menu" id="pauseMenu">
        <div class="menu-content">
            <div class="menu-title">‚öæ PAUSED ‚öæ</div>
            <button class="menu-button" onclick="resumeGame()">Resume Game</button>
            <button class="menu-button" onclick="restartGame()">Restart Game</button>
            <button class="menu-button" onclick="showTutorial()">Show Tutorial</button>
            <button class="menu-button" onclick="quitToMenu()">Quit to Menu</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class LoneStarLegendsGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });

                // Game state
                this.gameState = {
                    homeScore: 0,
                    awayScore: 0,
                    inning: 1,
                    isTopInning: true,
                    outs: 0,
                    balls: 0,
                    strikes: 0,
                    currentPhase: 'batting', // batting, running, fielding, pitching
                    isPaused: false,
                    gameStarted: false,
                    basesLoaded: [false, false, false], // 1st, 2nd, 3rd base
                    maxInnings: 9 // Default to 9 innings, can be set to 3 or 6
                };

                // Player control
                this.player = {
                    position: new THREE.Vector3(0, 0, 0),
                    battingPosition: new THREE.Vector3(-1, 0, 18)
                };

                // Input handling
                this.keys = {};
                this.powerMeter = 0;
                this.isChargingPower = false;
                this.maxPowerTime = 2000; // 2 seconds for full power

                // Game objects
                this.ball = null;
                this.bat = null;
                this.players = {
                    batter: null,
                    pitcher: null,
                    fielders: [],
                    runners: []
                };

                // Base running system
                this.basePositions = {
                    home: new THREE.Vector3(0, 0.1, 18.44),
                    first: new THREE.Vector3(18.44, 0.1, 0),
                    second: new THREE.Vector3(0, 0.1, -18.44),
                    third: new THREE.Vector3(-18.44, 0.1, 0)
                };

                this.activeRunner = null;
                this.runnerSpeed = 0.3;
                this.sprintMultiplier = 1.8;
                this.selectedFielder = null;

                // Physics
                this.ballPhysics = {
                    position: new THREE.Vector3(0, 1, -18),
                    velocity: new THREE.Vector3(0, 0, 0),
                    inPlay: false,
                    hasBeenHit: false,
                    isThrown: false
                };

                // Audio system for immersive sound effects
                this.audioContext = null;
                this.sounds = {};
                this.soundEnabled = true;
                this.masterVolume = 0.3; // 30% volume to avoid being too loud

                this.init();
            }

            async init() {
                try {
                    this.setupRenderer();
                    this.setupLighting();
                    this.createStadium();
                    this.createPlayers();
                    this.createBall();
                    this.setupCamera();
                    this.setupInput();
                    this.initAudio();
                    
                    // Hide loading screen
                    document.getElementById('loadingScreen').style.display = 'none';
                    
                    // Show tutorial
                    document.getElementById('tutorialOverlay').style.display = 'flex';
                    
                    this.animate();
                } catch (error) {
                    console.error('Failed to initialize game:', error);
                    this.showError('Failed to load game. Please refresh and try again.');
                }
            }

            showError(message) {
                document.getElementById('loadingScreen').innerHTML = `
                    <div style="color: #FF4444; font-size: 24px; text-align: center;">
                        <div>‚ùå Error</div>
                        <div style="font-size: 18px; margin-top: 20px;">${message}</div>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 15px 30px; font-size: 16px; background: #228B22; color: white; border: none; border-radius: 10px; cursor: pointer;">
                            Reload Game
                        </button>
                    </div>
                `;
            }

            // === AUDIO SYSTEM ===

            initAudio() {
                try {
                    // Initialize Web Audio API (user gesture required)
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.generateSounds();
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                    this.soundEnabled = false;
                }
            }

            async ensureAudioContext() {
                if (!this.audioContext || this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                    } catch (error) {
                        console.warn('Could not resume audio context:', error);
                        this.soundEnabled = false;
                    }
                }
            }

            generateSounds() {
                if (!this.audioContext) return;

                // Generate different sound types
                this.sounds = {
                    swing: this.createSwingSound(),
                    hit: this.createHitSound(),
                    catch: this.createCatchSound(),
                    homerun: this.createHomeRunSound(),
                    strike: this.createStrikeSound(),
                    crowd: this.createCrowdSound(),
                    throw: this.createThrowSound(),
                    bounce: this.createBounceSound()
                };
            }

            createSwingSound() {
                // Whoosh sound for bat swing
                return {
                    frequency: 150,
                    duration: 0.15,
                    type: 'noise',
                    envelope: { attack: 0.01, decay: 0.14 }
                };
            }

            createHitSound() {
                // Sharp crack sound for ball contact
                return {
                    frequency: 800,
                    duration: 0.1,
                    type: 'noise',
                    envelope: { attack: 0.001, decay: 0.099 }
                };
            }

            createCatchSound() {
                // Pop sound for ball in glove
                return {
                    frequency: 200,
                    duration: 0.08,
                    type: 'sine',
                    envelope: { attack: 0.01, decay: 0.07 }
                };
            }

            createHomeRunSound() {
                // Triumphant ascending tone
                return {
                    frequency: 440,
                    duration: 0.8,
                    type: 'sawtooth',
                    envelope: { attack: 0.1, decay: 0.7 },
                    pitch: { start: 440, end: 880 }
                };
            }

            createStrikeSound() {
                // Quick descending tone
                return {
                    frequency: 300,
                    duration: 0.3,
                    type: 'square',
                    envelope: { attack: 0.05, decay: 0.25 },
                    pitch: { start: 300, end: 150 }
                };
            }

            createCrowdSound() {
                // Crowd cheer (white noise burst)
                return {
                    frequency: 0, // White noise
                    duration: 1.5,
                    type: 'noise',
                    envelope: { attack: 0.2, decay: 1.3 }
                };
            }

            createThrowSound() {
                // Quick whoosh for ball throw
                return {
                    frequency: 300,
                    duration: 0.2,
                    type: 'noise',
                    envelope: { attack: 0.02, decay: 0.18 }
                };
            }

            createBounceSound() {
                // Ball bounce on ground
                return {
                    frequency: 150,
                    duration: 0.1,
                    type: 'sine',
                    envelope: { attack: 0.01, decay: 0.09 }
                };
            }

            async playSound(soundName, volume = 1) {
                if (!this.soundEnabled || !this.audioContext || !this.sounds[soundName]) return;

                try {
                    await this.ensureAudioContext();
                    
                    const sound = this.sounds[soundName];
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * sound.duration, this.audioContext.sampleRate);

                    // Connect audio nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    // Configure sound based on type
                    if (sound.type === 'noise') {
                        // Create white noise
                        const output = noiseBuffer.getChannelData(0);
                        for (let i = 0; i < noiseBuffer.length; i++) {
                            output[i] = Math.random() * 2 - 1;
                        }
                        
                        const noiseSource = this.audioContext.createBufferSource();
                        const noiseGain = this.audioContext.createGain();
                        
                        noiseSource.buffer = noiseBuffer;
                        noiseSource.connect(noiseGain);
                        noiseGain.connect(this.audioContext.destination);
                        
                        // Apply envelope
                        const now = this.audioContext.currentTime;
                        noiseGain.gain.setValueAtTime(0, now);
                        noiseGain.gain.linearRampToValueAtTime(volume * this.masterVolume, now + sound.envelope.attack);
                        noiseGain.gain.exponentialRampToValueAtTime(0.001, now + sound.envelope.attack + sound.envelope.decay);
                        
                        noiseSource.start(now);
                        noiseSource.stop(now + sound.duration);
                    } else {
                        // Use oscillator for tonal sounds
                        oscillator.type = sound.type;
                        oscillator.frequency.setValueAtTime(sound.frequency, this.audioContext.currentTime);
                        
                        // Apply pitch bend if specified
                        if (sound.pitch) {
                            oscillator.frequency.setValueAtTime(sound.pitch.start, this.audioContext.currentTime);
                            oscillator.frequency.linearRampToValueAtTime(sound.pitch.end, this.audioContext.currentTime + sound.duration);
                        }
                        
                        // Apply envelope
                        const now = this.audioContext.currentTime;
                        gainNode.gain.setValueAtTime(0, now);
                        gainNode.gain.linearRampToValueAtTime(volume * this.masterVolume, now + sound.envelope.attack);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + sound.envelope.attack + sound.envelope.decay);
                        
                        oscillator.start(now);
                        oscillator.stop(now + sound.duration);
                    }
                } catch (error) {
                    console.warn('Error playing sound:', soundName, error);
                }
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB); // Sky blue
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            setupLighting() {
                // Ambient lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // Stadium flood lights
                const lights = [
                    { pos: [80, 100, 40], intensity: 1.5 },
                    { pos: [-80, 100, 40], intensity: 1.5 },
                    { pos: [40, 100, -80], intensity: 1.2 },
                    { pos: [-40, 100, -80], intensity: 1.2 }
                ];

                lights.forEach(light => {
                    const spotLight = new THREE.SpotLight(0xffffff, light.intensity);
                    spotLight.position.set(...light.pos);
                    spotLight.angle = Math.PI / 3;
                    spotLight.penumbra = 0.2;
                    spotLight.decay = 2;
                    spotLight.distance = 400;
                    spotLight.castShadow = true;
                    spotLight.shadow.mapSize.width = 1024;
                    spotLight.shadow.mapSize.height = 1024;
                    this.scene.add(spotLight);
                });

                // Sun light
                const sunLight = new THREE.DirectionalLight(0xfffacd, 0.8);
                sunLight.position.set(200, 300, 100);
                sunLight.castShadow = true;
                sunLight.shadow.camera.near = 1;
                sunLight.shadow.camera.far = 500;
                sunLight.shadow.camera.left = -150;
                sunLight.shadow.camera.right = 150;
                sunLight.shadow.camera.top = 150;
                sunLight.shadow.camera.bottom = -150;
                this.scene.add(sunLight);
            }

            createStadium() {
                // Field grass (smaller for better performance)
                const fieldGeometry = new THREE.PlaneGeometry(300, 300);
                const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                field.rotation.x = -Math.PI / 2;
                field.receiveShadow = true;
                this.scene.add(field);

                // Infield dirt
                const infieldGeometry = new THREE.RingGeometry(0, 30, 4, 1);
                const infieldMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
                const infield = new THREE.Mesh(infieldGeometry, infieldMaterial);
                infield.rotation.x = -Math.PI / 2;
                infield.rotation.z = Math.PI / 4;
                infield.position.y = 0.01;
                infield.receiveShadow = true;
                this.scene.add(infield);

                // Pitcher's mound
                const moundGeometry = new THREE.CylinderGeometry(3, 4, 0.8, 16);
                const moundMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
                const mound = new THREE.Mesh(moundGeometry, moundMaterial);
                mound.position.set(0, 0.4, -18.44);
                mound.castShadow = true;
                mound.receiveShadow = true;
                this.scene.add(mound);

                // Create bases
                this.createBases();

                // Stadium walls (simpler geometry)
                this.createStadiumWalls();

                // Home plate
                const plateGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 5);
                const plateMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                plate.position.set(0, 0.05, 18.44);
                this.scene.add(plate);
            }

            createBases() {
                const baseGeometry = new THREE.BoxGeometry(1.5, 0.2, 1.5);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });

                // 90 feet = ~27.4 meters, scaled down for gameplay
                const baseDistance = 18.44;

                // First base
                const firstBase = new THREE.Mesh(baseGeometry, baseMaterial);
                firstBase.position.set(baseDistance, 0.1, 0);
                firstBase.castShadow = true;
                this.scene.add(firstBase);

                // Second base
                const secondBase = new THREE.Mesh(baseGeometry, baseMaterial);
                secondBase.position.set(0, 0.1, -baseDistance);
                secondBase.castShadow = true;
                this.scene.add(secondBase);

                // Third base
                const thirdBase = new THREE.Mesh(baseGeometry, baseMaterial);
                thirdBase.position.set(-baseDistance, 0.1, 0);
                thirdBase.castShadow = true;
                this.scene.add(thirdBase);
            }

            createStadiumWalls() {
                const wallHeight = 12;
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });

                // Outfield walls
                const walls = [
                    { pos: [-80, wallHeight/2, -60], size: [4, wallHeight, 120] }, // Left field
                    { pos: [0, wallHeight/2, -120], size: [160, wallHeight, 4] },   // Center field
                    { pos: [80, wallHeight/2, -60], size: [4, wallHeight, 120] }    // Right field
                ];

                walls.forEach(wall => {
                    const wallGeometry = new THREE.BoxGeometry(...wall.size);
                    const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                    wallMesh.position.set(...wall.pos);
                    wallMesh.castShadow = true;
                    wallMesh.receiveShadow = true;
                    this.scene.add(wallMesh);
                });

                // Foul poles
                const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 20);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                
                const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
                leftPole.position.set(-70, 10, -70);
                this.scene.add(leftPole);
                
                const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
                rightPole.position.set(70, 10, -70);
                this.scene.add(rightPole);
            }

            createPlayers() {
                // Create batter
                const batterGeometry = new THREE.CapsuleGeometry(0.8, 3.5);
                const batterMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4444 });
                this.players.batter = new THREE.Mesh(batterGeometry, batterMaterial);
                this.players.batter.position.copy(this.player.battingPosition);
                this.players.batter.position.y = 2;
                this.players.batter.castShadow = true;
                this.scene.add(this.players.batter);

                // Create bat
                const batGeometry = new THREE.CylinderGeometry(0.1, 0.15, 2.5);
                const batMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                this.bat = new THREE.Mesh(batGeometry, batMaterial);
                this.bat.position.set(-2.5, 2.5, 18.44);
                this.bat.rotation.z = Math.PI / 4;
                this.bat.castShadow = true;
                this.scene.add(this.bat);

                // Create pitcher
                const pitcherGeometry = new THREE.CapsuleGeometry(0.8, 3.5);
                const pitcherMaterial = new THREE.MeshLambertMaterial({ color: 0x4444FF });
                this.players.pitcher = new THREE.Mesh(pitcherGeometry, pitcherMaterial);
                this.players.pitcher.position.set(0, 2, -18.44);
                this.players.pitcher.castShadow = true;
                this.scene.add(this.players.pitcher);

                // Create fielders (simplified positions)
                const fielderPositions = [
                    [18, 2, 5],    // 1B
                    [12, 2, -8],   // 2B
                    [-18, 2, 5],   // 3B
                    [-12, 2, -8],  // SS
                    [-50, 2, -50], // LF
                    [0, 2, -80],   // CF
                    [50, 2, -50],  // RF
                    [0, 2, 22]     // C
                ];

                const fielderGeometry = new THREE.CapsuleGeometry(0.7, 3.2);
                const fielderMaterial = new THREE.MeshLambertMaterial({ color: 0x4444FF });

                fielderPositions.forEach(pos => {
                    const fielder = new THREE.Mesh(fielderGeometry, fielderMaterial);
                    fielder.position.set(...pos);
                    fielder.castShadow = true;
                    
                    // Initialize fielder userData
                    fielder.userData = {
                        selected: false,
                        originalPosition: new THREE.Vector3(...pos)
                    };
                    
                    this.players.fielders.push(fielder);
                    this.scene.add(fielder);
                });
            }

            createBall() {
                const ballGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                this.ball = new THREE.Mesh(ballGeometry, ballMaterial);
                this.ball.position.copy(this.ballPhysics.position);
                this.ball.castShadow = true;
                this.scene.add(this.ball);
            }

            setupCamera() {
                // Behind home plate camera angle
                this.camera.position.set(0, 10, 30);
                this.camera.lookAt(0, 2, -18);
            }

            setupInput() {
                document.addEventListener('keydown', (event) => {
                    this.keys[event.code] = true;
                    this.handleKeyDown(event);
                });

                document.addEventListener('keyup', (event) => {
                    this.keys[event.code] = false;
                    this.handleKeyUp(event);
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Prevent context menu on right click
                document.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }

            handleKeyDown(event) {
                if (!this.gameState.gameStarted || this.gameState.isPaused) return;

                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'batting') {
                            if (!this.isChargingPower) {
                                this.startPowerCharge();
                            }
                        } else if (this.gameState.currentPhase === 'fielding' && this.selectedFielder) {
                            this.throwBall();
                        }
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.advanceRunner();
                        }
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.retreatRunner();
                        }
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.selectPreviousRunner();
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'running') {
                            this.selectNextRunner();
                        }
                        break;
                    case 'Digit1':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('home');
                        }
                        break;
                    case 'Digit2':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('first');
                        }
                        break;
                    case 'Digit3':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('second');
                        }
                        break;
                    case 'Digit4':
                        event.preventDefault();
                        if (this.gameState.currentPhase === 'fielding') {
                            this.throwToBase('third');
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.togglePauseMenu();
                        break;
                    case 'KeyP':
                        event.preventDefault();
                        this.togglePause();
                        break;
                }
            }

            handleKeyUp(event) {
                if (!this.gameState.gameStarted || this.gameState.isPaused) return;

                switch(event.code) {
                    case 'Space':
                        if (this.gameState.currentPhase === 'batting' && this.isChargingPower) {
                            this.swing();
                        }
                        break;
                }
            }

            updatePlayerMovement() {
                if (!this.gameState.gameStarted || this.gameState.isPaused) return;

                const moveSpeed = 0.2;
                const sprintSpeed = (this.keys['ShiftLeft'] || this.keys['ShiftRight']) ? moveSpeed * this.sprintMultiplier : moveSpeed;

                if (this.gameState.currentPhase === 'batting') {
                    // Move in batter's box
                    if (this.keys['KeyW']) {
                        this.players.batter.position.z = Math.max(16, this.players.batter.position.z - moveSpeed);
                    }
                    if (this.keys['KeyS']) {
                        this.players.batter.position.z = Math.min(20, this.players.batter.position.z + moveSpeed);
                    }
                    if (this.keys['KeyA']) {
                        this.players.batter.position.x = Math.max(-3, this.players.batter.position.x - moveSpeed);
                    }
                    if (this.keys['KeyD']) {
                        this.players.batter.position.x = Math.min(1, this.players.batter.position.x + moveSpeed);
                    }
                } else if (this.gameState.currentPhase === 'fielding' && this.selectedFielder) {
                    // Control selected fielder with WASD
                    if (this.keys['KeyW']) {
                        this.selectedFielder.position.z -= sprintSpeed;
                    }
                    if (this.keys['KeyS']) {
                        this.selectedFielder.position.z += sprintSpeed;
                    }
                    if (this.keys['KeyA']) {
                        this.selectedFielder.position.x -= sprintSpeed;
                    }
                    if (this.keys['KeyD']) {
                        this.selectedFielder.position.x += sprintSpeed;
                    }
                }

                // Update runner animations
                this.updateRunnerMovement();
            }

            startPowerCharge() {
                this.isChargingPower = true;
                this.powerMeter = 0;
                this.powerStartTime = Date.now();
                document.getElementById('powerMeter').style.display = 'block';
                
                this.updateDynamicTip('Release SPACE to swing!');
                this.pitchBall();
            }

            updatePowerMeter() {
                if (this.isChargingPower) {
                    const elapsed = Date.now() - this.powerStartTime;
                    this.powerMeter = Math.min(100, (elapsed / this.maxPowerTime) * 100);
                    
                    document.getElementById('powerFill').style.height = this.powerMeter + '%';
                }
            }

            pitchBall() {
                // Reset ball
                this.ballPhysics.position.set(0, 1.5, -18.44);
                this.ballPhysics.velocity.set(0, 0, 0);
                this.ballPhysics.inPlay = true;
                this.ballPhysics.hasBeenHit = false;
                this.ballPhysics.isThrown = false;
                
                // AI Pitcher Decision Making
                const pitchDecision = this.choosePitchType();
                
                this.showCommentary(`${pitchDecision.name} - ${pitchDecision.speed} mph!`);
                this.updateDynamicTip(`${pitchDecision.description}`);
                this.animatePitcher();
            }

            choosePitchType() {
                // AI considers game situation
                const count = { balls: this.gameState.balls, strikes: this.gameState.strikes };
                const outs = this.gameState.outs;
                const runnersOnBase = this.players.runners.length > 0;
                
                // Pitch type probabilities based on count
                let pitchTypes = [];
                
                if (count.balls > count.strikes) {
                    // Behind in count - more likely to throw strikes
                    pitchTypes = [
                        { name: "Fastball", weight: 60, speed: [92, 98], accuracy: 0.8 },
                        { name: "Sinker", weight: 25, speed: [88, 94], accuracy: 0.75 },
                        { name: "Cutter", weight: 15, speed: [89, 95], accuracy: 0.7 }
                    ];
                } else if (count.strikes >= 2) {
                    // Ahead in count - can be more deceptive
                    pitchTypes = [
                        { name: "Slider", weight: 30, speed: [82, 88], accuracy: 0.6 },
                        { name: "Curveball", weight: 25, speed: [75, 82], accuracy: 0.55 },
                        { name: "Fastball", weight: 25, speed: [95, 100], accuracy: 0.7 },
                        { name: "Changeup", weight: 20, speed: [78, 85], accuracy: 0.65 }
                    ];
                } else {
                    // Even count - balanced approach
                    pitchTypes = [
                        { name: "Fastball", weight: 40, speed: [93, 99], accuracy: 0.75 },
                        { name: "Slider", weight: 20, speed: [83, 89], accuracy: 0.65 },
                        { name: "Changeup", weight: 20, speed: [79, 86], accuracy: 0.7 },
                        { name: "Curveball", weight: 20, speed: [76, 83], accuracy: 0.6 }
                    ];
                }
                
                // Select pitch based on weighted probability
                const totalWeight = pitchTypes.reduce((sum, pitch) => sum + pitch.weight, 0);
                let random = Math.random() * totalWeight;
                
                let selectedPitch = pitchTypes[0];
                for (const pitch of pitchTypes) {
                    random -= pitch.weight;
                    if (random <= 0) {
                        selectedPitch = pitch;
                        break;
                    }
                }
                
                // Determine actual pitch parameters
                const speed = selectedPitch.speed[0] + Math.random() * (selectedPitch.speed[1] - selectedPitch.speed[0]);
                const gameSpeed = (speed / 2.237) * 0.8; // Convert mph to game units
                
                // Accuracy affects location variation
                const accuracy = selectedPitch.accuracy;
                const baseVariation = 2.5;
                const horizontalVariation = (Math.random() - 0.5) * baseVariation * (1 - accuracy);
                const verticalVariation = (Math.random() - 0.5) * baseVariation * (1 - accuracy);
                
                // Apply pitch-specific movement
                let movement = this.getPitchMovement(selectedPitch.name);
                
                this.ballPhysics.velocity.set(
                    horizontalVariation + movement.horizontal,
                    verticalVariation + movement.vertical,
                    gameSpeed
                );
                
                return {
                    name: selectedPitch.name,
                    speed: speed.toFixed(0),
                    description: this.getPitchDescription(selectedPitch.name, count)
                };
            }

            getPitchMovement(pitchType) {
                switch(pitchType) {
                    case "Fastball":
                        return { horizontal: 0, vertical: 0.2 }; // Slight rise
                    case "Sinker":
                        return { horizontal: 0, vertical: -0.3 }; // Sinks down
                    case "Cutter":
                        return { horizontal: 0.3, vertical: 0 }; // Cuts away
                    case "Slider":
                        return { horizontal: 0.4, vertical: -0.2 }; // Breaks down and away
                    case "Curveball":
                        return { horizontal: 0.2, vertical: -0.5 }; // Big break down
                    case "Changeup":
                        return { horizontal: -0.1, vertical: -0.1 }; // Slight fade
                    default:
                        return { horizontal: 0, vertical: 0 };
                }
            }

            getPitchDescription(pitchType, count) {
                const situations = {
                    "Fastball": [
                        "Bringing the heat!", "Challenge pitch!", "High octane!", "Blow it by him!"
                    ],
                    "Slider": [
                        "Nasty break!", "Wipeout slider!", "Buckle your knees!", "Late movement!"
                    ],
                    "Curveball": [
                        "12-to-6 hammer!", "Uncle Charlie!", "Big hook!", "Drops off the table!"
                    ],
                    "Changeup": [
                        "Change of pace!", "Off-speed deception!", "Keeps him guessing!", "Slow and low!"
                    ],
                    "Sinker": [
                        "Heavy sinker!", "Ground ball pitch!", "Two-seam action!", "Induces weak contact!"
                    ],
                    "Cutter": [
                        "Sharp cutter!", "Late movement!", "Cuts the corners!", "Precision pitch!"
                    ]
                };
                
                const options = situations[pitchType] || ["Here's the pitch!"];
                return options[Math.floor(Math.random() * options.length)];
            }

            swing() {
                this.isChargingPower = false;
                document.getElementById('powerMeter').style.display = 'none';
                
                // Play swing sound and animate
                this.playSound('swing', 0.7);
                this.animateBatSwing();
                
                // Check for contact
                const ballPos = this.ballPhysics.position;
                const batterPos = this.players.batter.position;
                
                // Hit zone calculation
                const hitDistance = ballPos.distanceTo(batterPos);
                const isInStrikeZone = ballPos.z > 15 && ballPos.z < 22 && 
                                     ballPos.y > 0.5 && ballPos.y < 3.5 &&
                                     Math.abs(ballPos.x - batterPos.x) < 2.5;
                
                if (hitDistance < 3.5 && isInStrikeZone && this.ballPhysics.inPlay) {
                    this.hitBall();
                } else {
                    this.strike();
                }
            }

            hitBall() {
                this.ballPhysics.hasBeenHit = true;
                
                // Play hit sound
                this.playSound('hit', 0.8);
                
                // Calculate hit quality based on power and timing
                const power = this.powerMeter / 100;
                const contactQuality = 0.6 + Math.random() * 0.4;
                const totalPower = (power * 0.7 + contactQuality * 0.3);
                
                // Hit direction and elevation
                const angle = (Math.random() - 0.5) * Math.PI * 0.7; // Spread
                const elevation = Math.min(Math.PI / 3, totalPower * Math.PI / 2.5);
                
                const hitSpeed = 15 + totalPower * 35; // 15-50 m/s
                
                this.ballPhysics.velocity.set(
                    Math.sin(angle) * Math.cos(elevation) * hitSpeed,
                    Math.sin(elevation) * hitSpeed,
                    -Math.cos(angle) * Math.cos(elevation) * hitSpeed
                );
                
                // Update game phase
                this.gameState.currentPhase = 'fielding';
                this.updatePhaseIndicator();
                
                const exitVelocity = hitSpeed * 2.237; // Convert to mph
                let hitType = this.determineHitType(exitVelocity, elevation);
                
                // Create a runner on first base (batter becomes runner)
                this.addRunnerOnBase(1);
                
                // Auto-select closest fielder
                this.selectClosestFielder();
                
                this.showCommentary(`${hitType} - ${exitVelocity.toFixed(0)} mph!`);
                this.updateDynamicTip('Ball in play! Control fielders with WASD!');
            }

            determineHitType(velocity, elevation) {
                if (velocity > 105 && elevation > 0.4) return "CRUSHED! Home run potential!";
                if (velocity > 95) return "SMASHED! Deep drive!";
                if (velocity > 85) return "SOLID contact! Line drive!";
                if (elevation < 0.2) return "Ground ball hit!";
                return "Fly ball in the air!";
            }

            strike() {
                this.gameState.strikes++;
                
                // Play strike sound
                this.playSound('strike', 0.6);
                
                if (this.gameState.strikes >= 3) {
                    this.strikeout();
                } else {
                    this.showCommentary(`Strike ${this.gameState.strikes}!`);
                    this.updateDynamicTip(`${this.gameState.strikes} strikes - be careful!`);
                }
                
                this.updateHUD();
                this.resetForNextPitch();
            }

            strikeout() {
                this.gameState.outs++;
                this.showCommentary("Strike three! You're out!");
                this.updateDynamicTip("Strikeout! Next batter up.");
                
                if (this.gameState.outs >= 3) {
                    this.endInning();
                } else {
                    this.nextBatter();
                }
            }

            nextBatter() {
                this.gameState.balls = 0;
                this.gameState.strikes = 0;
                this.gameState.currentPhase = 'batting';
                
                this.players.batter.position.copy(this.player.battingPosition);
                this.players.batter.position.y = 2;
                
                this.updateHUD();
                this.updatePhaseIndicator();
                this.updateDynamicTip("New batter - get ready!");
                this.resetForNextPitch();
            }

            endInning() {
                this.gameState.outs = 0;
                
                // Clear all runners from bases
                this.clearAllRunners();
                
                // Switch between top and bottom of inning
                if (this.gameState.isTopInning) {
                    // End of top half - switch to bottom
                    this.gameState.isTopInning = false;
                    this.showCommentary(`Middle of the ${this.ordinalNumber(this.gameState.inning)} - Home team batting!`);
                    this.updateDynamicTip('Time for the home team to bat!');
                } else {
                    // End of bottom half - advance to next inning
                    this.gameState.isTopInning = true;
                    this.gameState.inning++;
                    
                    // Check for game end
                    if (this.gameState.inning > this.gameState.maxInnings) {
                        this.checkGameEnd();
                        return;
                    }
                    
                    this.showCommentary(`Starting the ${this.ordinalNumber(this.gameState.inning)} inning!`);
                    this.updateDynamicTip('Away team up to bat!');
                }
                
                // Update display and continue
                this.updateHUD();
                this.updatePhaseIndicator();
                
                // Switch teams
                this.switchTeams();
                
                // Reset for next half-inning
                setTimeout(() => {
                    this.nextBatter();
                }, 2000);
            }

            ordinalNumber(num) {
                const ordinals = ['', '1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th'];
                return ordinals[num] || `${num}th`;
            }

            clearAllRunners() {
                // Remove all runners from the field
                this.players.runners.forEach(runner => {
                    this.scene.remove(runner);
                });
                this.players.runners = [];
                this.activeRunner = null;
                this.gameState.basesLoaded = [false, false, false];
            }

            switchTeams() {
                // Swap team colors for visual indication
                if (this.gameState.isTopInning) {
                    // Away team batting (red), home team fielding (blue)
                    this.players.batter.material.color.setHex(0xFF0000);
                    this.players.fielders.forEach(f => f.material.color.setHex(0x0000FF));
                } else {
                    // Home team batting (blue), away team fielding (red)
                    this.players.batter.material.color.setHex(0x0000FF);
                    this.players.fielders.forEach(f => f.material.color.setHex(0xFF0000));
                }
            }

            checkGameEnd() {
                const homeWins = this.gameState.homeScore > this.gameState.awayScore;
                const awayWins = this.gameState.awayScore > this.gameState.homeScore;
                
                if (homeWins || awayWins) {
                    this.endGame(homeWins);
                } else {
                    // Extra innings if tied
                    this.showCommentary("TIED GAME! Going to extra innings!");
                    this.updateDynamicTip("Extra innings! Next run wins!");
                    this.gameState.isTopInning = true;
                    this.updateHUD();
                    setTimeout(() => {
                        this.nextBatter();
                    }, 3000);
                }
            }

            endGame(homeWins) {
                // Game over!
                this.gameState.gameStarted = false;
                this.gameState.currentPhase = 'gameover';
                
                // Play celebration sounds
                this.playSound('homerun', 1.0);
                setTimeout(() => this.playSound('crowd', 0.8), 500);
                
                const winner = homeWins ? 'HOME TEAM' : 'AWAY TEAM';
                const finalScore = `${this.gameState.awayScore} - ${this.gameState.homeScore}`;
                
                // Show game over screen
                const gameOverScreen = document.createElement('div');
                gameOverScreen.id = 'gameOverScreen';
                gameOverScreen.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                    color: white;
                    font-family: 'Arial Black', Arial, sans-serif;
                `;
                
                gameOverScreen.innerHTML = `
                    <div style="text-align: center;">
                        <h1 style="font-size: 72px; color: #FFD700; margin-bottom: 20px;">
                            GAME OVER!
                        </h1>
                        <h2 style="font-size: 48px; color: #90EE90; margin-bottom: 30px;">
                            ${winner} WINS!
                        </h2>
                        <div style="font-size: 36px; color: #FFF; margin-bottom: 40px;">
                            Final Score: ${finalScore}
                        </div>
                        <div style="font-size: 24px; color: #CCC; margin-bottom: 50px;">
                            ${this.gameState.inning - 1} innings played
                        </div>
                        <button onclick="location.reload()" style="
                            padding: 20px 40px;
                            font-size: 24px;
                            background: linear-gradient(45deg, #228B22, #32CD32);
                            color: white;
                            border: 3px solid #90EE90;
                            border-radius: 15px;
                            cursor: pointer;
                            font-weight: bold;
                            transition: all 0.3s;
                        " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                            PLAY AGAIN
                        </button>
                    </div>
                `;
                
                document.body.appendChild(gameOverScreen);
                
                // Update final commentary
                this.showCommentary(`üéâ ${winner} WINS! Final: ${finalScore} üéâ`);
            }

            resetForNextPitch() {
                this.ballPhysics.inPlay = false;
                this.ballPhysics.position.set(0, 1.5, -18.44);
                this.ballPhysics.velocity.set(0, 0, 0);
                this.ball.position.copy(this.ballPhysics.position);
            }

            updateBallPhysics() {
                if (!this.ballPhysics.inPlay) return;
                
                const deltaTime = 0.016; // 60fps
                
                // Update position
                this.ballPhysics.position.add(
                    this.ballPhysics.velocity.clone().multiplyScalar(deltaTime)
                );
                
                // Apply gravity
                this.ballPhysics.velocity.y -= 9.8 * deltaTime;
                
                // Ground collision
                if (this.ballPhysics.position.y <= 0.15) {
                    // Play bounce sound if significant bounce
                    if (Math.abs(this.ballPhysics.velocity.y) > 2) {
                        this.playSound('bounce', 0.4);
                    }
                    
                    this.ballPhysics.position.y = 0.15;
                    this.ballPhysics.velocity.y = Math.abs(this.ballPhysics.velocity.y) * 0.4;
                    this.ballPhysics.velocity.x *= 0.7;
                    this.ballPhysics.velocity.z *= 0.7;
                    
                    if (Math.abs(this.ballPhysics.velocity.y) < 0.1) {
                        this.ballPhysics.velocity.y = 0;
                    }
                }
                
                // Update visual ball
                this.ball.position.copy(this.ballPhysics.position);
                
                // Check for player catch attempt
                if (this.gameState.currentPhase === 'fielding' && this.selectedFielder) {
                    this.attemptCatch();
                }
                
                // Update fielder AI
                this.updateFielderAI();
                
                // Check for home run
                this.checkHomeRun();
                
                // Check if ball is out of play
                if (Math.abs(this.ballPhysics.position.x) > 150 || 
                    Math.abs(this.ballPhysics.position.z) > 150) {
                    this.ballOutOfPlay();
                }
            }

            checkHomeRun() {
                const ballPos = this.ballPhysics.position;
                
                // Check if ball cleared the wall
                if (ballPos.z < -110 && ballPos.y > 10) {
                    this.homeRun();
                }
            }

            homeRun() {
                // Score for the team that's currently batting
                if (this.gameState.isTopInning) {
                    this.gameState.awayScore++;
                } else {
                    this.gameState.homeScore++;
                }
                
                // Play celebratory home run sound and crowd cheer
                this.playSound('homerun', 1.0);
                setTimeout(() => this.playSound('crowd', 0.6), 200);
                
                this.showCommentary("üéâ HOME RUN! IT'S OUTTA HERE! üéâ");
                this.updateDynamicTip("HOME RUN! Amazing!");
                
                this.ballPhysics.inPlay = false;
                this.nextBatter();
                this.updateHUD();
            }

            ballOutOfPlay() {
                this.ballPhysics.inPlay = false;
                this.gameState.currentPhase = 'batting';
                this.updatePhaseIndicator();
                this.updateDynamicTip("Ball is out of play - next pitch!");
                this.resetForNextPitch();
            }

            animateBatSwing() {
                const originalRotation = this.bat.rotation.z;
                const originalPosition = this.bat.position.x;
                
                // Quick swing animation
                this.bat.rotation.z = -Math.PI / 6;
                this.bat.position.x -= 0.8;
                
                setTimeout(() => {
                    this.bat.rotation.z = originalRotation;
                    this.bat.position.x = originalPosition;
                }, 250);
            }

            animatePitcher() {
                const originalY = this.players.pitcher.position.y;
                const originalRotation = this.players.pitcher.rotation.x;
                
                // Wind up
                this.players.pitcher.rotation.x = -0.2;
                this.players.pitcher.position.y = originalY - 0.3;
                
                setTimeout(() => {
                    // Follow through
                    this.players.pitcher.rotation.x = 0.2;
                }, 300);
                
                setTimeout(() => {
                    // Return to normal
                    this.players.pitcher.rotation.x = originalRotation;
                    this.players.pitcher.position.y = originalY;
                }, 800);
            }

            // === BASE RUNNING SYSTEM ===
            
            createRunner(baseNumber = 0) {
                // Create a visual runner
                const runnerGeometry = new THREE.CapsuleGeometry(0.4, 1.8);
                const runnerMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
                
                // Position runner at base
                if (baseNumber === 0) {
                    runner.position.copy(this.basePositions.home);
                } else if (baseNumber === 1) {
                    runner.position.copy(this.basePositions.first);
                } else if (baseNumber === 2) {
                    runner.position.copy(this.basePositions.second);
                } else if (baseNumber === 3) {
                    runner.position.copy(this.basePositions.third);
                }
                
                runner.position.y = 1;
                runner.castShadow = true;
                
                runner.userData = {
                    currentBase: baseNumber,
                    targetBase: baseNumber,
                    isMoving: false,
                    moveProgress: 0,
                    selected: false
                };
                
                this.scene.add(runner);
                this.players.runners.push(runner);
                
                // Update base status
                if (baseNumber > 0) {
                    this.gameState.basesLoaded[baseNumber - 1] = true;
                }
                
                return runner;
            }

            addRunnerOnBase(baseNumber) {
                // Check if base already occupied
                if (baseNumber === 1 && this.gameState.basesLoaded[0]) return;
                if (baseNumber === 2 && this.gameState.basesLoaded[1]) return;
                if (baseNumber === 3 && this.gameState.basesLoaded[2]) return;
                
                const runner = this.createRunner(baseNumber);
                
                // Make this the active runner
                this.selectRunner(runner);
                
                this.showCommentary(`Runner on ${this.getBaseName(baseNumber)}!`);
                this.gameState.currentPhase = 'running';
                this.updatePhaseIndicator();
                this.updateDynamicTip('Use arrow keys to control runner!');
            }

            getBaseName(baseNumber) {
                const baseNames = ['Home', 'First', 'Second', 'Third'];
                return baseNames[baseNumber] || 'Unknown';
            }

            selectRunner(runner) {
                // Deselect all runners
                this.players.runners.forEach(r => {
                    r.userData.selected = false;
                    r.material.color.setHex(0xFF0000); // Red
                });
                
                // Select new runner
                if (runner) {
                    this.activeRunner = runner;
                    runner.userData.selected = true;
                    runner.material.color.setHex(0xFFD700); // Gold
                }
            }

            selectNextRunner() {
                if (this.players.runners.length === 0) return;
                
                let currentIndex = this.players.runners.indexOf(this.activeRunner);
                currentIndex = (currentIndex + 1) % this.players.runners.length;
                this.selectRunner(this.players.runners[currentIndex]);
                
                const baseName = this.getBaseName(this.activeRunner.userData.currentBase);
                this.updateDynamicTip(`Selected runner on ${baseName}`);
            }

            selectPreviousRunner() {
                if (this.players.runners.length === 0) return;
                
                let currentIndex = this.players.runners.indexOf(this.activeRunner);
                currentIndex = (currentIndex - 1 + this.players.runners.length) % this.players.runners.length;
                this.selectRunner(this.players.runners[currentIndex]);
                
                const baseName = this.getBaseName(this.activeRunner.userData.currentBase);
                this.updateDynamicTip(`Selected runner on ${baseName}`);
            }

            advanceRunner() {
                if (!this.activeRunner || this.activeRunner.userData.isMoving) return;
                
                const currentBase = this.activeRunner.userData.currentBase;
                const nextBase = (currentBase + 1) % 4;
                
                // Check if next base is occupied
                if (nextBase > 0 && nextBase < 4 && this.gameState.basesLoaded[nextBase - 1]) {
                    this.updateDynamicTip(`${this.getBaseName(nextBase)} is occupied!`);
                    return;
                }
                
                this.moveRunnerToBase(this.activeRunner, nextBase);
            }

            retreatRunner() {
                if (!this.activeRunner || this.activeRunner.userData.isMoving) return;
                
                const currentBase = this.activeRunner.userData.currentBase;
                if (currentBase === 0) return; // Can't retreat from home
                
                const prevBase = currentBase - 1;
                
                // Check if previous base is occupied
                if (prevBase > 0 && this.gameState.basesLoaded[prevBase - 1]) {
                    this.updateDynamicTip(`${this.getBaseName(prevBase)} is occupied!`);
                    return;
                }
                
                this.moveRunnerToBase(this.activeRunner, prevBase);
            }

            moveRunnerToBase(runner, targetBase) {
                if (!runner || runner.userData.isMoving) return;
                
                const currentBase = runner.userData.currentBase;
                
                // Clear current base
                if (currentBase > 0) {
                    this.gameState.basesLoaded[currentBase - 1] = false;
                }
                
                runner.userData.targetBase = targetBase;
                runner.userData.isMoving = true;
                runner.userData.moveProgress = 0;
                
                const baseName = this.getBaseName(targetBase);
                this.showCommentary(`Running to ${baseName}!`);
                
                // Check for scoring
                if (targetBase === 0) {
                    this.showCommentary('RUNNER SCORES!');
                    
                    // Score for the team that's currently batting
                    if (this.gameState.isTopInning) {
                        this.gameState.awayScore++;
                    } else {
                        this.gameState.homeScore++;
                    }
                    
                    // Play scoring sound
                    this.playSound('crowd', 0.5);
                    
                    this.updateHUD();
                }
            }

            updateRunnerMovement() {
                this.players.runners.forEach(runner => {
                    if (!runner.userData.isMoving) return;
                    
                    const speed = this.runnerSpeed;
                    runner.userData.moveProgress += speed;
                    
                    if (runner.userData.moveProgress >= 1.0) {
                        // Reached target base
                        runner.userData.moveProgress = 1.0;
                        runner.userData.isMoving = false;
                        runner.userData.currentBase = runner.userData.targetBase;
                        
                        // Update base status
                        if (runner.userData.currentBase > 0 && runner.userData.currentBase < 4) {
                            this.gameState.basesLoaded[runner.userData.currentBase - 1] = true;
                        }
                        
                        // Remove runner if they reached home
                        if (runner.userData.currentBase === 0) {
                            this.scene.remove(runner);
                            const index = this.players.runners.indexOf(runner);
                            this.players.runners.splice(index, 1);
                            
                            // Select next runner if needed
                            if (this.activeRunner === runner && this.players.runners.length > 0) {
                                this.selectRunner(this.players.runners[0]);
                            } else if (this.players.runners.length === 0) {
                                this.activeRunner = null;
                                this.gameState.currentPhase = 'batting';
                                this.updatePhaseIndicator();
                                this.updateDynamicTip('Get ready for the next batter!');
                            }
                        }
                    } else {
                        // Interpolate position
                        const currentPos = this.getBasePosition(runner.userData.currentBase);
                        const targetPos = this.getBasePosition(runner.userData.targetBase);
                        
                        runner.position.lerpVectors(currentPos, targetPos, runner.userData.moveProgress);
                        runner.position.y = 1; // Keep runner at ground level
                    }
                });
            }

            getBasePosition(baseNumber) {
                switch(baseNumber) {
                    case 0: return this.basePositions.home.clone();
                    case 1: return this.basePositions.first.clone();
                    case 2: return this.basePositions.second.clone();
                    case 3: return this.basePositions.third.clone();
                    default: return this.basePositions.home.clone();
                }
            }

            // === FIELDING SYSTEM ===
            
            throwToBase(baseName) {
                if (!this.selectedFielder) {
                    this.selectClosestFielder();
                    return;
                }
                
                // Calculate throw trajectory and speed
                const throwSpeed = 25; // m/s
                const targetPosition = this.basePositions[baseName].clone();
                targetPosition.y = 1.5; // Chest height
                
                const direction = targetPosition.clone().sub(this.selectedFielder.position).normalize();
                
                // Reset ball position to fielder
                this.ballPhysics.position.copy(this.selectedFielder.position);
                this.ballPhysics.position.y += 1.5; // Throwing height
                
                // Set ball velocity towards base
                this.ballPhysics.velocity.copy(direction.multiplyScalar(throwSpeed));
                this.ballPhysics.inPlay = true;
                this.ballPhysics.hasBeenHit = false;
                this.ballPhysics.isThrown = true;
                
                // Play throw sound
                this.playSound('throw', 0.7);
                
                this.showCommentary(`Throwing to ${baseName}!`);
                this.updateDynamicTip('Ball thrown - watch the play!');
                
                // Animate fielder throw
                this.animateFielderThrow(this.selectedFielder);
            }

            selectClosestFielder() {
                if (this.players.fielders.length === 0) return;
                
                // Find fielder closest to ball
                let closestFielder = null;
                let closestDistance = Infinity;
                
                this.players.fielders.forEach(fielder => {
                    const distance = fielder.position.distanceTo(this.ballPhysics.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestFielder = fielder;
                    }
                });
                
                if (closestFielder) {
                    this.selectFielder(closestFielder);
                }
            }

            selectFielder(fielder) {
                // Deselect all fielders
                this.players.fielders.forEach(f => {
                    f.material.color.setHex(0x0000FF); // Blue
                    f.userData.selected = false;
                });
                
                // Select new fielder
                this.selectedFielder = fielder;
                fielder.material.color.setHex(0xFFD700); // Gold
                fielder.userData.selected = true;
                
                this.updateDynamicTip('Control fielder with WASD, SPACE to throw');
            }

            attemptCatch() {
                if (!this.selectedFielder || !this.ballPhysics.inPlay) return false;
                
                const ballPos = new THREE.Vector3().copy(this.ballPhysics.position);
                const fielderPos = this.selectedFielder.position.clone();
                fielderPos.y += 1; // Fielder reach height
                
                const catchRadius = 2.5; // Catching range
                const distance = ballPos.distanceTo(fielderPos);
                
                if (distance <= catchRadius && ballPos.y <= 3 && ballPos.y >= 0.2) {
                    // Successful catch!
                    this.ballPhysics.inPlay = false;
                    this.ballPhysics.velocity.set(0, 0, 0);
                    
                    // Play catch sound
                    this.playSound('catch', 0.8);
                    
                    // Position ball in fielder's glove
                    this.ballPhysics.position.copy(fielderPos);
                    
                    this.showCommentary('CAUGHT! Great defensive play!');
                    this.updateDynamicTip('Ball caught! Press 1-4 to throw to bases');
                    
                    // Animate catch
                    this.animateFielderCatch(this.selectedFielder);
                    
                    // Update game state
                    this.gameState.outs++;
                    this.updateHUD();
                    
                    if (this.gameState.outs >= 3) {
                        this.endInning();
                    }
                    
                    return true;
                }
                
                return false;
            }

            updateFielderAI() {
                if (!this.ballPhysics.inPlay || this.ballPhysics.isThrown) return;
                
                this.players.fielders.forEach(fielder => {
                    if (fielder === this.selectedFielder) return; // Don't AI-control selected fielder
                    
                    const ballPos = new THREE.Vector3().copy(this.ballPhysics.position);
                    const fielderPos = fielder.position;
                    const distance = fielderPos.distanceTo(ballPos);
                    
                    // Only move if ball is relatively close and in the air or bouncing
                    if (distance < 30 && ballPos.y > 0.5) {
                        const direction = ballPos.clone().sub(fielderPos).normalize();
                        const moveSpeed = 0.15;
                        
                        // Move towards ball but don't overshoot
                        if (distance > 2) {
                            fielder.position.add(direction.multiplyScalar(moveSpeed));
                        }
                        
                        // Attempt automatic catch for AI fielders
                        const catchRadius = 2.0;
                        if (distance <= catchRadius && ballPos.y <= 3 && ballPos.y >= 0.2) {
                            this.ballPhysics.inPlay = false;
                            this.ballPhysics.velocity.set(0, 0, 0);
                            this.ballPhysics.position.copy(fielder.position);
                            this.ballPhysics.position.y = 1.5;
                            
                            // Play catch sound for AI fielder
                            this.playSound('catch', 0.8);
                            
                            this.showCommentary('Fielder makes the catch!');
                            this.selectFielder(fielder);
                            this.updateDynamicTip('Ball caught by AI fielder! Take control with WASD');
                            
                            this.gameState.outs++;
                            this.updateHUD();
                            
                            if (this.gameState.outs >= 3) {
                                this.endInning();
                            }
                        }
                    }
                });
            }

            animateFielderCatch(fielder) {
                const originalY = fielder.position.y;
                const originalScale = fielder.scale.y;
                
                // Jump slightly for catch
                fielder.position.y = originalY + 0.3;
                fielder.scale.y = originalScale * 1.1;
                
                setTimeout(() => {
                    fielder.position.y = originalY;
                    fielder.scale.y = originalScale;
                }, 300);
            }

            animateFielderThrow(fielder) {
                const originalRotation = fielder.rotation.z;
                
                // Throwing motion
                fielder.rotation.z = Math.PI / 6;
                
                setTimeout(() => {
                    fielder.rotation.z = -Math.PI / 6;
                }, 150);
                
                setTimeout(() => {
                    fielder.rotation.z = originalRotation;
                }, 400);
            }

            showCommentary(text) {
                const commentary = document.getElementById('commentary');
                commentary.textContent = text;
                commentary.classList.add('show');
                
                setTimeout(() => {
                    commentary.classList.remove('show');
                }, 3000);
            }

            updatePhaseIndicator() {
                const indicator = document.getElementById('phaseIndicator');
                const phases = {
                    'batting': 'BATTING',
                    'fielding': 'FIELDING',
                    'running': 'RUNNING'
                };
                indicator.textContent = phases[this.gameState.currentPhase] || 'PLAYING';
            }

            updateDynamicTip(text) {
                document.getElementById('dynamicTip').textContent = text;
            }

            updateHUD() {
                document.getElementById('homeScore').textContent = this.gameState.homeScore;
                document.getElementById('awayScore').textContent = this.gameState.awayScore;
                document.getElementById('inning').textContent = this.gameState.inning;
                document.getElementById('inningHalf').textContent = this.gameState.isTopInning ? 'TOP' : 'BOT';
                document.getElementById('balls').textContent = this.gameState.balls;
                document.getElementById('strikes').textContent = this.gameState.strikes;
                document.getElementById('outs').textContent = this.gameState.outs;
            }

            togglePauseMenu() {
                const menu = document.getElementById('pauseMenu');
                if (menu.style.display === 'flex') {
                    menu.style.display = 'none';
                    this.gameState.isPaused = false;
                } else {
                    menu.style.display = 'flex';
                    this.gameState.isPaused = true;
                }
            }

            togglePause() {
                this.gameState.isPaused = !this.gameState.isPaused;
                this.showCommentary(this.gameState.isPaused ? "‚è∏Ô∏è Game Paused" : "‚ñ∂Ô∏è Game Resumed");
            }

            startNewGame() {
                this.gameState = {
                    homeScore: 0,
                    awayScore: 0,
                    inning: 1,
                    isTopInning: true,
                    outs: 0,
                    balls: 0,
                    strikes: 0,
                    currentPhase: 'batting',
                    isPaused: false,
                    gameStarted: true,
                    basesLoaded: [false, false, false],
                    maxInnings: selectedGameLength // Use the selected game length
                };
                
                this.players.batter.position.copy(this.player.battingPosition);
                this.players.batter.position.y = 2;
                
                this.resetForNextPitch();
                this.updateHUD();
                this.updatePhaseIndicator();
                this.updateDynamicTip("Play ball! Hold SPACE to charge your swing!");
                
                // Clear any runners from previous game
                this.clearAllRunners();
                
                // Set initial team colors
                this.switchTeams();
                
                this.showCommentary(`‚öæ PLAY BALL! ${this.gameState.maxInnings}-inning game starting! ‚öæ`);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.gameState.gameStarted && !this.gameState.isPaused) {
                    this.updatePlayerMovement();
                    this.updatePowerMeter();
                    this.updateBallPhysics();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Global game instance
        let game;
        let selectedGameLength = 9; // Default to 9 innings

        // Global control functions
        function setGameLength(innings) {
            selectedGameLength = innings;
            document.getElementById('selectedInnings').textContent = innings;
            
            // Update button styling
            const buttons = document.querySelectorAll('.tutorial-section button');
            buttons.forEach(btn => {
                if (btn.textContent.includes(innings)) {
                    btn.style.background = 'linear-gradient(45deg, #FFD700, #FFA500)';
                } else if (btn.textContent.includes('Innings')) {
                    btn.style.background = 'linear-gradient(45deg, #228B22, #32CD32)';
                }
            });
        }

        function startGame() {
            document.getElementById('tutorialOverlay').style.display = 'none';
            if (game) {
                game.startNewGame();
            }
        }

        function skipTutorial() {
            startGame();
        }

        function resumeGame() {
            document.getElementById('pauseMenu').style.display = 'none';
            if (game) game.gameState.isPaused = false;
        }

        function restartGame() {
            if (game) {
                game.startNewGame();
                resumeGame();
            }
        }

        function showTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'flex';
            resumeGame();
        }

        function quitToMenu() {
            if (confirm("Return to main menu?")) {
                window.location.href = 'index.html';
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            game = new LoneStarLegendsGame();
        });

        // Prevent accidental page refresh
        window.addEventListener('beforeunload', (event) => {
            if (game && game.gameState.gameStarted) {
                event.preventDefault();
                event.returnValue = '';
            }
        });
    </script>
</body>
</html>