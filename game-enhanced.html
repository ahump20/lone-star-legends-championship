<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blaze Intelligence - Lone Star Legends Championship</title>
    <link rel="stylesheet" href="css/blaze-theme.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            background: var(--blaze-navy);
            color: var(--blaze-white);
            font-family: var(--font-body);
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Scoreboard */
        .scoreboard {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--blaze-gradient-midnight);
            border: 2px solid var(--blaze-orange);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            backdrop-filter: blur(10px);
            pointer-events: auto;
            min-width: 600px;
        }

        .score-header {
            display: grid;
            grid-template-columns: 2fr 1fr 2fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .team-score {
            text-align: center;
        }

        .team-name {
            font-family: var(--font-heading);
            font-size: 1.2rem;
            color: var(--blaze-orange);
            margin-bottom: var(--spacing-xs);
        }

        .score-value {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .inning-display {
            text-align: center;
            padding: var(--spacing-md);
            background: rgba(255, 107, 53, 0.1);
            border-radius: var(--radius-md);
        }

        .inning-label {
            font-size: 0.9rem;
            color: var(--blaze-gray-light);
            text-transform: uppercase;
        }

        .inning-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--blaze-orange);
        }

        /* Count Display */
        .count-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
            padding-top: var(--spacing-md);
            border-top: 1px solid rgba(255, 107, 53, 0.2);
        }

        .count-item {
            text-align: center;
        }

        .count-label {
            font-size: 0.8rem;
            color: var(--blaze-gray-light);
            text-transform: uppercase;
        }

        .count-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: var(--spacing-xs);
        }

        .count-indicators {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: var(--spacing-xs);
        }

        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--blaze-gray-dark);
        }

        .indicator.active {
            background: var(--blaze-orange);
            box-shadow: 0 0 10px var(--blaze-orange);
        }

        /* Base Display */
        .bases-display {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        .base-diamond {
            position: relative;
            width: 100px;
            height: 100px;
            transform: rotate(45deg);
            margin: 25px auto;
        }

        .base {
            position: absolute;
            width: 20px;
            height: 20px;
            background: var(--blaze-gray-dark);
            border: 2px solid var(--blaze-orange);
            transition: all var(--transition-base);
        }

        .base.occupied {
            background: var(--blaze-orange);
            box-shadow: 0 0 15px var(--blaze-orange);
        }

        .base.first { top: 40px; right: 0; }
        .base.second { top: 0; left: 40px; }
        .base.third { top: 40px; left: 0; }
        .base.home { bottom: 0; left: 40px; }

        /* Controls */
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--spacing-md);
            pointer-events: auto;
        }

        .control-btn {
            padding: var(--spacing-md) var(--spacing-xl);
            background: var(--blaze-gradient-primary);
            border: none;
            border-radius: var(--radius-md);
            color: var(--blaze-white);
            font-family: var(--font-heading);
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            transition: all var(--transition-base);
            box-shadow: var(--shadow-orange);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-orange-lg);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn.secondary {
            background: transparent;
            border: 2px solid var(--blaze-orange);
        }

        /* Play by Play */
        .play-log {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            max-height: 400px;
            background: var(--blaze-gradient-midnight);
            border: 1px solid rgba(255, 107, 53, 0.2);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            pointer-events: auto;
            overflow-y: auto;
        }

        .play-log-header {
            font-family: var(--font-heading);
            font-size: 1.2rem;
            color: var(--blaze-orange);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid rgba(255, 107, 53, 0.2);
        }

        .play-item {
            padding: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
            background: rgba(255, 107, 53, 0.05);
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            color: var(--blaze-gray-light);
            animation: slideIn 0.3s ease;
        }

        .play-item.highlight {
            background: rgba(255, 107, 53, 0.15);
            color: var(--blaze-white);
            border-left: 3px solid var(--blaze-orange);
        }

        /* Batter Info */
        .batter-info {
            position: absolute;
            right: 20px;
            bottom: 120px;
            background: var(--blaze-gradient-midnight);
            border: 1px solid rgba(255, 107, 53, 0.2);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            pointer-events: auto;
            min-width: 250px;
        }

        .batter-name {
            font-family: var(--font-heading);
            font-size: 1.3rem;
            color: var(--blaze-orange);
            margin-bottom: var(--spacing-sm);
        }

        .batter-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            font-size: 0.9rem;
        }

        .stat-label {
            color: var(--blaze-gray-light);
        }

        .stat-value {
            color: var(--blaze-white);
            font-weight: 600;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--blaze-navy);
            border: 2px solid var(--blaze-orange);
            border-radius: var(--radius-xl);
            padding: var(--spacing-2xl);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-family: var(--font-heading);
            font-size: 2rem;
            color: var(--blaze-orange);
            margin-bottom: var(--spacing-lg);
            text-align: center;
        }

        .modal-body {
            color: var(--blaze-gray-light);
            line-height: 1.6;
        }

        .modal-actions {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            margin-top: var(--spacing-xl);
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--blaze-navy);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--blaze-gray-dark);
            border-top: 4px solid var(--blaze-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: var(--spacing-xl);
            font-family: var(--font-heading);
            font-size: 1.5rem;
            color: var(--blaze-orange);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Game Engine...</div>
    </div>

    <!-- 3D Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Game UI Overlay -->
    <div class="game-ui">
        <!-- Scoreboard -->
        <div class="scoreboard">
            <div class="score-header">
                <div class="team-score">
                    <div class="team-name" id="awayTeamName">Longhorns</div>
                    <div class="score-value" id="awayScore">0</div>
                </div>
                <div class="inning-display">
                    <div class="inning-label" id="inningHalf">Top</div>
                    <div class="inning-value" id="inningNumber">1</div>
                </div>
                <div class="team-score">
                    <div class="team-name" id="homeTeamName">Cardinals</div>
                    <div class="score-value" id="homeScore">0</div>
                </div>
            </div>
            
            <div class="count-display">
                <div class="count-item">
                    <div class="count-label">Balls</div>
                    <div class="count-indicators" id="ballIndicators">
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                    </div>
                </div>
                <div class="count-item">
                    <div class="count-label">Strikes</div>
                    <div class="count-indicators" id="strikeIndicators">
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                    </div>
                </div>
                <div class="count-item">
                    <div class="count-label">Outs</div>
                    <div class="count-indicators" id="outIndicators">
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                        <span class="indicator"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Base Display -->
        <div class="bases-display">
            <div class="base-diamond">
                <div class="base second" id="base2"></div>
                <div class="base third" id="base3"></div>
                <div class="base first" id="base1"></div>
                <div class="base home"></div>
            </div>
        </div>

        <!-- Play by Play -->
        <div class="play-log">
            <div class="play-log-header">Play by Play</div>
            <div id="playLog"></div>
        </div>

        <!-- Batter Info -->
        <div class="batter-info">
            <div class="batter-name" id="batterName">Loading...</div>
            <div class="batter-stats">
                <span class="stat-label">AVG:</span>
                <span class="stat-value" id="batterAvg">-</span>
                <span class="stat-label">AB:</span>
                <span class="stat-value" id="batterAB">-</span>
                <span class="stat-label">H:</span>
                <span class="stat-value" id="batterHits">-</span>
                <span class="stat-label">RBI:</span>
                <span class="stat-value" id="batterRBI">-</span>
            </div>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button class="control-btn" id="pitchBtn">‚öæ PITCH</button>
            <button class="control-btn secondary" id="pauseBtn">‚è∏ PAUSE</button>
            <button class="control-btn secondary" id="resetBtn">üîÑ RESET</button>
            <button class="control-btn secondary" id="exportBtn">üìä EXPORT</button>
            <button class="control-btn secondary" id="autoBtn">ü§ñ AUTO</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <div class="modal-header">üèÜ Game Over!</div>
            <div class="modal-body" id="gameOverStats">
                <!-- Final stats will be inserted here -->
            </div>
            <div class="modal-actions">
                <button class="control-btn" onclick="resetGame()">Play Again</button>
                <button class="control-btn secondary" onclick="exportGameData()">Export Stats</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/baseball-game-engine.js"></script>
    <script>
        // Initialize game engine
        let gameEngine;
        let scene, camera, renderer;
        let isAutoPlay = false;
        let autoPlayInterval;
        let fieldGroup;
        let baseMeshes = [];
        let scoreboardCanvas;
        let scoreboardTexture;
        let scoreboardContext;
        let scoreboardMesh;

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initGame();
            initThreeJS();
            hideLoadingScreen();
        });

        function initGame() {
            gameEngine = new BaseballGameEngine();
            gameEngine.startGame();
            updateUI();
            
            // Setup event listeners
            document.getElementById('pitchBtn').addEventListener('click', pitch);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
            document.getElementById('exportBtn').addEventListener('click', exportGameData);
            document.getElementById('autoBtn').addEventListener('click', toggleAutoPlay);
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0A0E27, 10, 140);

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 32, 56);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x1f2a4a, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.1);
            directionalLight.position.set(18, 45, 22);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 120;
            scene.add(directionalLight);

            const rimLight = new THREE.DirectionalLight(0x6aa7ff, 0.4);
            rimLight.position.set(-32, 35, -18);
            scene.add(rimLight);

            // Stadium spot lights
            const leftSpot = new THREE.SpotLight(0xffffff, 0.5, 180, Math.PI / 4, 0.6, 1.2);
            leftSpot.position.set(-45, 42, 28);
            leftSpot.target.position.set(-5, 0, 0);
            leftSpot.castShadow = true;
            scene.add(leftSpot);
            scene.add(leftSpot.target);

            const rightSpot = new THREE.SpotLight(0xffffff, 0.5, 180, Math.PI / 4, 0.6, 1.2);
            rightSpot.position.set(45, 42, 28);
            rightSpot.target.position.set(5, 0, 0);
            rightSpot.castShadow = true;
            scene.add(rightSpot);
            scene.add(rightSpot.target);

            const centerSpot = new THREE.SpotLight(0xbad9ff, 0.45, 200, Math.PI / 5, 0.7, 1.4);
            centerSpot.position.set(0, 46, -12);
            centerSpot.target.position.set(0, 0, 0);
            centerSpot.castShadow = true;
            scene.add(centerSpot);
            scene.add(centerSpot.target);

            // Create baseball field
            createBaseballField();

            // Animation loop
            animate();
        }

        function createBaseballField() {
            fieldGroup = new THREE.Group();
            fieldGroup.name = 'mlbField';

            const mowingTexture = createMowingPatternTexture();
            mowingTexture.wrapS = THREE.RepeatWrapping;
            mowingTexture.wrapT = THREE.RepeatWrapping;
            mowingTexture.repeat.set(9, 9);

            const fieldMaterial = new THREE.MeshStandardMaterial({
                map: mowingTexture,
                color: 0x2d5f23,
                roughness: 0.65
            });
            const playingSurface = new THREE.Mesh(new THREE.CircleGeometry(55, 128), fieldMaterial);
            playingSurface.rotation.x = -Math.PI / 2;
            playingSurface.receiveShadow = true;
            fieldGroup.add(playingSurface);

            const warningTrack = new THREE.Mesh(
                new THREE.RingGeometry(42, 55, 128),
                new THREE.MeshStandardMaterial({ color: 0x8d5f39, roughness: 0.9 })
            );
            warningTrack.rotation.x = -Math.PI / 2;
            warningTrack.position.y = 0.01;
            warningTrack.receiveShadow = true;
            fieldGroup.add(warningTrack);

            const infieldDirt = new THREE.Mesh(
                new THREE.CircleGeometry(18, 64),
                new THREE.MeshStandardMaterial({ color: 0xc08f5a, roughness: 0.95 })
            );
            infieldDirt.rotation.x = -Math.PI / 2;
            infieldDirt.position.y = 0.02;
            infieldDirt.receiveShadow = true;
            fieldGroup.add(infieldDirt);

            const infieldGrass = new THREE.Mesh(
                new THREE.RingGeometry(10, 18, 64),
                new THREE.MeshStandardMaterial({ color: 0x29612a, roughness: 0.7 })
            );
            infieldGrass.rotation.x = -Math.PI / 2;
            infieldGrass.position.y = 0.018;
            fieldGroup.add(infieldGrass);

            const basePathShape = new THREE.Shape();
            basePathShape.moveTo(0, 24);
            basePathShape.lineTo(24, 0);
            basePathShape.lineTo(0, -24);
            basePathShape.lineTo(-24, 0);
            basePathShape.closePath();
            const infieldHole = new THREE.Path();
            infieldHole.moveTo(0, 12);
            infieldHole.lineTo(12, 0);
            infieldHole.lineTo(0, -12);
            infieldHole.lineTo(-12, 0);
            infieldHole.closePath();
            basePathShape.holes.push(infieldHole);

            const basePath = new THREE.Mesh(
                new THREE.ShapeGeometry(basePathShape),
                new THREE.MeshStandardMaterial({ color: 0xcd9a66, roughness: 0.95 })
            );
            basePath.rotation.x = -Math.PI / 2;
            basePath.position.y = 0.025;
            basePath.receiveShadow = true;
            fieldGroup.add(basePath);

            const homeCircle = new THREE.Mesh(
                new THREE.RingGeometry(3.2, 4.2, 48),
                new THREE.MeshStandardMaterial({ color: 0xcd9a66, roughness: 0.9 })
            );
            homeCircle.rotation.x = -Math.PI / 2;
            homeCircle.position.set(0, 0.021, 13);
            fieldGroup.add(homeCircle);

            const homePlateShape = new THREE.Shape();
            homePlateShape.moveTo(0, 0.9);
            homePlateShape.lineTo(0.7, 0);
            homePlateShape.lineTo(0.7, -0.9);
            homePlateShape.lineTo(-0.7, -0.9);
            homePlateShape.lineTo(-0.7, 0);
            homePlateShape.closePath();
            const homePlate = new THREE.Mesh(
                new THREE.ShapeGeometry(homePlateShape),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.35 })
            );
            homePlate.rotation.x = -Math.PI / 2;
            homePlate.position.set(0, 0.032, 13);
            homePlate.receiveShadow = true;
            fieldGroup.add(homePlate);

            const batterBoxMaterial = new THREE.MeshStandardMaterial({ color: 0xf6f7f7, roughness: 0.3 });
            const batterBoxGeometry = new THREE.PlaneGeometry(4, 2);
            const leftBatterBox = new THREE.Mesh(batterBoxGeometry, batterBoxMaterial);
            leftBatterBox.rotation.x = -Math.PI / 2;
            leftBatterBox.position.set(-3.2, 0.028, 11.7);
            fieldGroup.add(leftBatterBox);
            const rightBatterBox = leftBatterBox.clone();
            rightBatterBox.position.set(3.2, 0.028, 11.7);
            fieldGroup.add(rightBatterBox);

            const onDeckMaterial = new THREE.MeshStandardMaterial({ color: 0x374164, roughness: 0.8 });
            const onDeckGeometry = new THREE.CircleGeometry(2.3, 32);
            const leftOnDeck = new THREE.Mesh(onDeckGeometry, onDeckMaterial);
            leftOnDeck.rotation.x = -Math.PI / 2;
            leftOnDeck.position.set(-18, 0.02, 25);
            fieldGroup.add(leftOnDeck);
            const rightOnDeck = leftOnDeck.clone();
            rightOnDeck.position.set(18, 0.02, 25);
            fieldGroup.add(rightOnDeck);

            const mound = new THREE.Mesh(
                new THREE.CylinderGeometry(3, 5, 0.8, 32),
                new THREE.MeshStandardMaterial({ color: 0xcd9a66, roughness: 0.95 })
            );
            mound.position.set(0, 0.4, 6);
            mound.receiveShadow = true;
            mound.castShadow = true;
            fieldGroup.add(mound);

            const rubber = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 0.5),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 })
            );
            rubber.position.set(0, 0.85, 6);
            fieldGroup.add(rubber);

            const foulLineMaterial = new THREE.MeshStandardMaterial({
                color: 0xf5f8fa,
                emissive: 0xffffff,
                emissiveIntensity: 0.25,
                roughness: 0.2
            });
            const homePosition = new THREE.Vector3(0, 0.03, 13);
            const firstBasePosition = new THREE.Vector3(13, 0.03, 0);
            const secondBasePosition = new THREE.Vector3(0, 0.08, -13);
            const thirdBasePosition = new THREE.Vector3(-13, 0.03, 0);
            const foulLine1 = createBaseline(homePosition, firstBasePosition, foulLineMaterial);
            const foulLine3 = createBaseline(homePosition, thirdBasePosition, foulLineMaterial);
            fieldGroup.add(foulLine1);
            fieldGroup.add(foulLine3);

            baseMeshes = [];
            const baseGeometry = new THREE.BoxGeometry(1.6, 0.12, 1.6);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.05, roughness: 0.3 });
            [firstBasePosition, secondBasePosition, thirdBasePosition].forEach((position) => {
                const base = new THREE.Mesh(baseGeometry, baseMaterial.clone());
                base.position.copy(position);
                base.rotation.y = Math.PI / 4;
                base.castShadow = true;
                base.receiveShadow = true;
                base.material.emissive = new THREE.Color(0xffa94d);
                base.material.emissiveIntensity = 0;
                baseMeshes.push(base);
                fieldGroup.add(base);
            });

            const baseAnchorGeometry = new THREE.CircleGeometry(1.5, 32);
            const baseAnchorMaterial = new THREE.MeshStandardMaterial({ color: 0xcd9a66, roughness: 0.9 });
            [firstBasePosition, secondBasePosition, thirdBasePosition].forEach((position) => {
                const anchor = new THREE.Mesh(baseAnchorGeometry, baseAnchorMaterial);
                anchor.rotation.x = -Math.PI / 2;
                anchor.position.set(position.x, 0.023, position.z);
                fieldGroup.add(anchor);
            });

            const centerLogoTexture = createCenterFieldLogoTexture();
            const centerLogo = new THREE.Mesh(
                new THREE.CircleGeometry(6, 48),
                new THREE.MeshBasicMaterial({ map: centerLogoTexture, transparent: true })
            );
            centerLogo.rotation.x = -Math.PI / 2;
            centerLogo.position.set(0, 0.021, -20);
            fieldGroup.add(centerLogo);

            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x123870, roughness: 0.7, metalness: 0.15 });
            const wallRadius = 44;
            for (let i = -6; i <= 6; i++) {
                const angle = (i / 6) * (Math.PI / 2);
                const wallSegment = new THREE.Mesh(new THREE.BoxGeometry(6, 5, 1), wallMaterial);
                const x = Math.sin(angle) * wallRadius;
                const z = -Math.cos(angle) * wallRadius;
                wallSegment.position.set(x, 2.5, z);
                wallSegment.rotation.y = angle;
                wallSegment.castShadow = true;
                wallSegment.receiveShadow = true;
                fieldGroup.add(wallSegment);

                if (i % 3 === 0) {
                    const markerCanvas = document.createElement('canvas');
                    markerCanvas.width = 128;
                    markerCanvas.height = 128;
                    const markerCtx = markerCanvas.getContext('2d');
                    markerCtx.fillStyle = '#0f2a52';
                    markerCtx.fillRect(0, 0, markerCanvas.width, markerCanvas.height);
                    markerCtx.fillStyle = '#f3f4f8';
                    markerCtx.font = 'bold 64px sans-serif';
                    const distance = 390 + Math.abs(i) * 5;
                    markerCtx.fillText(`${distance}`, 20, 78);
                    const markerTexture = new THREE.CanvasTexture(markerCanvas);
                    const marker = new THREE.Mesh(
                        new THREE.PlaneGeometry(3, 3),
                        new THREE.MeshBasicMaterial({ map: markerTexture })
                    );
                    marker.position.set(x, 2.5, z - 0.6);
                    marker.rotation.y = angle;
                    fieldGroup.add(marker);
                }
            }

            const bullpenMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3626, roughness: 0.85 });
            const leftBullpen = new THREE.Mesh(new THREE.BoxGeometry(10, 0.6, 4), bullpenMaterial);
            leftBullpen.position.set(-28, 0.3, -24);
            leftBullpen.receiveShadow = true;
            fieldGroup.add(leftBullpen);
            const rightBullpen = leftBullpen.clone();
            rightBullpen.position.set(28, 0.3, -24);
            fieldGroup.add(rightBullpen);

            const dugoutMaterial = new THREE.MeshStandardMaterial({ color: 0x1f293b, roughness: 0.6 });
            const leftDugout = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 4), dugoutMaterial);
            leftDugout.position.set(-12, 1, 20);
            leftDugout.rotation.y = Math.PI / 10;
            fieldGroup.add(leftDugout);
            const rightDugout = leftDugout.clone();
            rightDugout.position.set(12, 1, 20);
            rightDugout.rotation.y = -Math.PI / 10;
            fieldGroup.add(rightDugout);

            const seatingMaterial = new THREE.MeshStandardMaterial({ color: 0x1b2232, roughness: 0.75 });
            for (let tier = 0; tier < 3; tier++) {
                const radius = 30 + tier * 5;
                for (let i = -5; i <= 5; i++) {
                    const angle = (i / 5) * (Math.PI / 2.8);
                    const section = new THREE.Mesh(new THREE.BoxGeometry(5, 1.2, 8), seatingMaterial);
                    const x = Math.sin(angle) * radius;
                    const z = 22 + Math.cos(angle) * 8 - tier * 1.5;
                    section.position.set(x, 2 + tier * 1.2, z);
                    section.rotation.y = angle;
                    section.castShadow = true;
                    fieldGroup.add(section);
                }
            }

            const lightPositions = [
                [-38, -30],
                [38, -30],
                [-30, 28],
                [30, 28]
            ];
            lightPositions.forEach(([x, z]) => {
                const tower = createLightTower(x, z);
                fieldGroup.add(tower);
            });

            const netting = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 10),
                new THREE.MeshStandardMaterial({
                    color: 0x10151f,
                    transparent: true,
                    opacity: 0.35,
                    side: THREE.DoubleSide
                })
            );
            netting.position.set(0, 5, 26);
            fieldGroup.add(netting);

            const concourse = new THREE.Mesh(
                new THREE.RingGeometry(55, 65, 128),
                new THREE.MeshStandardMaterial({ color: 0x2a303f, roughness: 0.8 })
            );
            concourse.rotation.x = -Math.PI / 2;
            concourse.position.y = -0.02;
            fieldGroup.add(concourse);

            const skyline = new THREE.Mesh(
                new THREE.PlaneGeometry(160, 60),
                new THREE.MeshBasicMaterial({ color: 0x081022, transparent: true, opacity: 0.8 })
            );
            skyline.position.set(0, 20, -80);
            fieldGroup.add(skyline);

            const initialState = gameEngine ? gameEngine.getGameState() : null;
            scoreboardMesh = createScoreboardMesh(initialState);
            if (scoreboardMesh) {
                fieldGroup.add(scoreboardMesh);
            }

            scene.add(fieldGroup);
        }

        function createBaseline(start, end, material) {
            const length = start.distanceTo(end);
            const baseline = new THREE.Mesh(new THREE.PlaneGeometry(length, 0.45), material);
            baseline.rotation.x = -Math.PI / 2;
            const midpoint = start.clone().add(end).multiplyScalar(0.5);
            baseline.position.copy(midpoint);
            const angle = Math.atan2(end.x - start.x, end.z - start.z);
            baseline.rotation.y = angle;
            baseline.receiveShadow = true;
            return baseline;
        }

        function createLightTower(x, z) {
            const tower = new THREE.Group();
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.6, 18, 16),
                new THREE.MeshStandardMaterial({ color: 0xd6dae2, metalness: 0.6, roughness: 0.3 })
            );
            pole.position.y = 9;
            tower.add(pole);

            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(5, 1, 1.2),
                new THREE.MeshStandardMaterial({ color: 0x1c2333, metalness: 0.5, roughness: 0.5 })
            );
            frame.position.y = 17.5;
            tower.add(frame);

            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 4; col++) {
                    const light = new THREE.Mesh(
                        new THREE.CircleGeometry(0.45, 20),
                        new THREE.MeshBasicMaterial({ color: 0xf8f9ff })
                    );
                    light.position.set(-1.5 + col, 17.5 + row * 0.9, 0.62);
                    light.rotation.y = Math.PI;
                    tower.add(light);
                }
            }

            const glow = new THREE.PointLight(0xffffff, 0.35, 80, 2);
            glow.position.set(0, 18, 0.5);
            tower.add(glow);

            tower.position.set(x, 0, z);
            return tower;
        }

        function createMowingPatternTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            const stripes = 12;
            const stripeHeight = canvas.height / stripes;

            for (let i = 0; i < stripes; i++) {
                const gradient = ctx.createLinearGradient(0, i * stripeHeight, canvas.width, (i + 1) * stripeHeight);
                gradient.addColorStop(0, i % 2 === 0 ? '#1f4a17' : '#163813');
                gradient.addColorStop(1, i % 2 === 0 ? '#265d1f' : '#1d4c18');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, i * stripeHeight, canvas.width, stripeHeight);
            }

            ctx.globalAlpha = 0.08;
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2;
                ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#000000';
                ctx.fillRect(x, y, size, size);
            }
            ctx.globalAlpha = 1;

            return new THREE.CanvasTexture(canvas);
        }

        function createCenterFieldLogoTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(256, 256, 40, 256, 256, 240);
            gradient.addColorStop(0, 'rgba(255, 107, 53, 0.95)');
            gradient.addColorStop(1, 'rgba(11, 18, 39, 0.9)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(256, 256, 240, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.arc(256, 256, 220, 0, Math.PI * 2);
            ctx.stroke();

            ctx.font = 'bold 72px "Space Grotesk", sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('BLAZE', 256, 210);
            ctx.fillText('SPORTS INTEL', 256, 280);

            ctx.font = 'bold 48px "Inter", sans-serif';
            ctx.fillStyle = '#ffb347';
            ctx.fillText('CHAMPIONSHIP SERIES', 256, 350);

            return new THREE.CanvasTexture(canvas);
        }

        function createScoreboardMesh(state) {
            scoreboardCanvas = document.createElement('canvas');
            scoreboardCanvas.width = 1024;
            scoreboardCanvas.height = 512;
            scoreboardContext = scoreboardCanvas.getContext('2d');
            drawScoreboardCanvas(state);

            scoreboardTexture = new THREE.CanvasTexture(scoreboardCanvas);
            scoreboardTexture.anisotropy = renderer.capabilities.getMaxAnisotropy() || 1;
            scoreboardTexture.needsUpdate = true;

            const screen = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 15),
                new THREE.MeshBasicMaterial({ map: scoreboardTexture, transparent: true })
            );
            screen.position.set(0, 14, -48);

            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(32, 17, 1),
                new THREE.MeshStandardMaterial({ color: 0x0b101d, roughness: 0.6, metalness: 0.4 })
            );
            frame.position.set(0, 14, -48.6);
            frame.castShadow = true;
            fieldGroup.add(frame);

            const lightBar = new THREE.PointLight(0x89b4ff, 0.35, 50, 2);
            lightBar.position.set(0, 22, -48);
            fieldGroup.add(lightBar);

            return screen;
        }

        function drawScoreboardCanvas(state) {
            if (!scoreboardContext) return;

            const ctx = scoreboardContext;
            ctx.clearRect(0, 0, scoreboardCanvas.width, scoreboardCanvas.height);

            const bgGradient = ctx.createLinearGradient(0, 0, scoreboardCanvas.width, scoreboardCanvas.height);
            bgGradient.addColorStop(0, '#0d1c38');
            bgGradient.addColorStop(1, '#020812');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, scoreboardCanvas.width, scoreboardCanvas.height);

            ctx.fillStyle = '#ff6b35';
            ctx.font = 'bold 52px "Space Grotesk", sans-serif';
            ctx.fillText('LONE STAR LEGENDS CHAMPIONSHIP', 60, 80);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 4;
            ctx.strokeRect(40, 110, scoreboardCanvas.width - 80, 200);

            const awayTeam = state?.teams?.away?.name || 'Away';
            const homeTeam = state?.teams?.home?.name || 'Home';
            const awayScore = state?.teams?.away?.score ?? 0;
            const homeScore = state?.teams?.home?.score ?? 0;
            const inning = state?.inning ?? 1;
            const isTop = state?.isTopInning ?? true;
            const balls = state?.balls ?? 0;
            const strikes = state?.strikes ?? 0;
            const outs = state?.outs ?? 0;

            ctx.fillStyle = '#f5f6f8';
            ctx.font = 'bold 60px "Inter", sans-serif';
            ctx.fillText(awayTeam.toUpperCase(), 80, 190);
            ctx.fillText(homeTeam.toUpperCase(), 80, 270);

            ctx.textAlign = 'right';
            ctx.font = 'bold 96px "Space Grotesk", sans-serif';
            ctx.fillText(awayScore, scoreboardCanvas.width - 100, 200);
            ctx.fillText(homeScore, scoreboardCanvas.width - 100, 280);

            ctx.textAlign = 'left';
            ctx.font = 'bold 44px "Inter", sans-serif';
            ctx.fillStyle = '#9cb7ff';
            ctx.fillText(`${isTop ? 'TOP' : 'BOTTOM'} ${inning}`, 60, 340);

            ctx.fillStyle = '#f5f6f8';
            ctx.font = '32px "Inter", sans-serif';
            ctx.fillText(`BALLS ${balls}   STRIKES ${strikes}   OUTS ${outs}`, 60, 390);

            const hitsAway = state?.teams?.away?.hits ?? 0;
            const hitsHome = state?.teams?.home?.hits ?? 0;
            const errorsAway = state?.teams?.away?.errors ?? 0;
            const errorsHome = state?.teams?.home?.errors ?? 0;
            ctx.fillText(`HITS ${hitsAway} / ${hitsHome}     ERRORS ${errorsAway} / ${errorsHome}`, 60, 440);

            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.font = '28px "Inter", sans-serif';
            ctx.fillText('Powered by BlazeSportsIntel.com', 60, 490);
        }

        function updateScoreboard3D(state) {
            if (!scoreboardTexture || !scoreboardContext) return;
            drawScoreboardCanvas(state);
            scoreboardTexture.needsUpdate = true;
        }

        function update3DBases(bases) {
            if (!baseMeshes || !baseMeshes.length) return;
            baseMeshes.forEach((mesh, index) => {
                const occupied = !!bases[index];
                mesh.material.emissiveIntensity = occupied ? 0.85 : 0;
                mesh.material.color.setHex(occupied ? 0xfff0d2 : 0xffffff);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.00035;
            camera.position.x = Math.sin(time) * 6.5;
            camera.position.z = 56 + Math.sin(time * 0.5) * 2.5;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        function pitch() {
            if (gameEngine.gameOver) return;
            
            const result = gameEngine.pitch();
            if (result) {
                updateUI();
                
                // Check if game is over
                if (gameEngine.gameOver) {
                    showGameOver();
                }
            }
        }

        function updateUI() {
            const state = gameEngine.getGameState();
            
            // Update scores
            document.getElementById('awayScore').textContent = state.teams.away.score;
            document.getElementById('homeScore').textContent = state.teams.home.score;
            
            // Update inning
            document.getElementById('inningHalf').textContent = state.isTopInning ? 'Top' : 'Bottom';
            document.getElementById('inningNumber').textContent = state.inning;
            
            // Update count indicators
            updateIndicators('ballIndicators', state.balls, 4);
            updateIndicators('strikeIndicators', state.strikes, 3);
            updateIndicators('outIndicators', state.outs, 3);
            
            // Update bases
            updateBases(state.bases);
            update3DBases(state.bases);

            updateScoreboard3D(state);
            
            // Update batter info
            if (state.currentBatter) {
                document.getElementById('batterName').textContent = state.currentBatter;
                const batter = gameEngine.currentBatter;
                if (batter) {
                    document.getElementById('batterAvg').textContent = batter.battingAverage.toFixed(3);
                    document.getElementById('batterAB').textContent = batter.atBats;
                    document.getElementById('batterHits').textContent = batter.hits;
                    document.getElementById('batterRBI').textContent = batter.rbis;
                }
            }
            
            // Update play log
            updatePlayLog(state.playByPlay);
        }

        function updateIndicators(elementId, count, max) {
            const indicators = document.getElementById(elementId).children;
            for (let i = 0; i < max; i++) {
                indicators[i].classList.toggle('active', i < count);
            }
        }

        function updateBases(bases) {
            document.getElementById('base1').classList.toggle('occupied', bases[0] !== null);
            document.getElementById('base2').classList.toggle('occupied', bases[1] !== null);
            document.getElementById('base3').classList.toggle('occupied', bases[2] !== null);
        }

        function updatePlayLog(plays) {
            const logElement = document.getElementById('playLog');
            logElement.innerHTML = '';
            
            plays.forEach((play, index) => {
                const playItem = document.createElement('div');
                playItem.className = 'play-item';
                if (index === 0) playItem.classList.add('highlight');
                playItem.textContent = play;
                logElement.appendChild(playItem);
            });
        }

        function togglePause() {
            const btn = document.getElementById('pauseBtn');
            if (gameEngine.isPaused) {
                gameEngine.resumeGame();
                btn.textContent = '‚è∏ PAUSE';
            } else {
                gameEngine.pauseGame();
                btn.textContent = '‚ñ∂ RESUME';
            }
        }

        function resetGame() {
            if (confirm('Are you sure you want to reset the game?')) {
                gameEngine.resetGame();
                gameEngine.startGame();
                updateUI();
                document.getElementById('gameOverModal').classList.remove('active');
                if (isAutoPlay) {
                    toggleAutoPlay();
                }
            }
        }

        function toggleAutoPlay() {
            isAutoPlay = !isAutoPlay;
            const btn = document.getElementById('autoBtn');
            
            if (isAutoPlay) {
                btn.textContent = '‚èπ STOP';
                autoPlayInterval = setInterval(() => {
                    if (!gameEngine.gameOver && !gameEngine.isPaused) {
                        pitch();
                    } else if (gameEngine.gameOver) {
                        clearInterval(autoPlayInterval);
                        isAutoPlay = false;
                        btn.textContent = 'ü§ñ AUTO';
                    }
                }, 2000);
            } else {
                btn.textContent = 'ü§ñ AUTO';
                clearInterval(autoPlayInterval);
            }
        }

        function exportGameData() {
            const state = gameEngine.getGameState();
            const exportData = {
                game: {
                    date: new Date().toISOString(),
                    teams: state.teams,
                    finalScore: `${state.teams.away.name} ${state.teams.away.score} - ${state.teams.home.name} ${state.teams.home.score}`,
                    innings: state.inning
                },
                statistics: state.stats,
                playByPlay: gameEngine.gameLog
            };
            
            // Create and download JSON file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `blaze-game-${Date.now()}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            alert('Game data exported successfully!');
        }

        function showGameOver() {
            const state = gameEngine.getGameState();
            const modal = document.getElementById('gameOverModal');
            const statsElement = document.getElementById('gameOverStats');
            
            const winner = state.teams.home.score > state.teams.away.score ? state.teams.home : state.teams.away;
            const loser = winner === state.teams.home ? state.teams.away : state.teams.home;
            
            statsElement.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="color: var(--blaze-orange);">${winner.name} Win!</h2>
                    <div style="font-size: 2rem; margin: 10px 0;">
                        ${winner.score} - ${loser.score}
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h3 style="color: var(--blaze-orange); margin-bottom: 10px;">${state.teams.away.name}</h3>
                        <p>Hits: ${state.teams.away.hits}</p>
                        <p>Errors: ${state.teams.away.errors}</p>
                    </div>
                    <div>
                        <h3 style="color: var(--blaze-orange); margin-bottom: 10px;">${state.teams.home.name}</h3>
                        <p>Hits: ${state.teams.home.hits}</p>
                        <p>Errors: ${state.teams.home.errors}</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255, 107, 53, 0.2);">
                    <h3 style="color: var(--blaze-orange); margin-bottom: 10px;">Game Statistics</h3>
                    <p>Total Pitches: ${state.stats.totalPitches}</p>
                    <p>Total Hits: ${state.stats.totalHits}</p>
                    <p>Home Runs: ${state.stats.homeRuns}</p>
                    <p>Strikeouts: ${state.stats.strikeouts}</p>
                    <p>Walks: ${state.stats.walks}</p>
                </div>
            `;
            
            modal.classList.add('active');
        }

        function hideLoadingScreen() {
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 1000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>