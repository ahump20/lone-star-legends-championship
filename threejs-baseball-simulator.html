<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lone Star Legends - Three.js Baseball Simulator</title>
    <style>
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .scoreboard {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid gold;
            border-radius: 10px;
            padding: 15px 30px;
            color: white;
            pointer-events: auto;
        }
        
        .score-display {
            display: flex;
            justify-content: space-around;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .team-score {
            text-align: center;
            margin: 0 20px;
        }
        
        .team-name {
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .inning-display {
            text-align: center;
            font-size: 14px;
            color: #aaa;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .stats-panel {
            position: absolute;
            right: 20px;
            top: 100px;
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #4a90e2;
            border-radius: 10px;
            padding: 15px;
            color: white;
            pointer-events: auto;
        }
        
        .stats-title {
            font-size: 16px;
            color: #4a90e2;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        
        .momentum-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 15px;
            overflow: hidden;
            pointer-events: none;
        }
        
        .momentum-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2 0%, #ff6b6b 100%);
            width: 50%;
            transition: width 0.5s ease;
        }
        
        .ai-commentary {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ffd700;
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffd700;
            text-align: center;
            font-style: italic;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .ai-commentary.active {
            opacity: 1;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
        }
        
        .camera-controls {
            position: absolute;
            left: 20px;
            top: 100px;
            pointer-events: auto;
        }
        
        .camera-btn {
            display: block;
            margin: 5px 0;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #4a90e2;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .camera-btn:hover {
            background: rgba(74, 144, 226, 0.3);
        }
        
        .camera-btn.active {
            background: #4a90e2;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Stadium...</div>
    
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div class="scoreboard">
            <div class="score-display">
                <div class="team-score">
                    <div class="team-name">HOME</div>
                    <div id="home-score">0</div>
                </div>
                <div class="team-score">
                    <div class="team-name">AWAY</div>
                    <div id="away-score">0</div>
                </div>
            </div>
            <div class="inning-display">
                Inning: <span id="inning">1</span> - <span id="half">TOP</span>
            </div>
        </div>
        
        <div class="camera-controls">
            <button class="camera-btn active" onclick="setCamera('broadcast')">Broadcast</button>
            <button class="camera-btn" onclick="setCamera('pitcher')">Pitcher View</button>
            <button class="camera-btn" onclick="setCamera('batter')">Batter View</button>
            <button class="camera-btn" onclick="setCamera('aerial')">Aerial View</button>
        </div>
        
        <div class="stats-panel">
            <div class="stats-title">Live Statistics</div>
            <div class="stat-item">
                <span>Exit Velocity:</span>
                <span id="exit-velocity">0 mph</span>
            </div>
            <div class="stat-item">
                <span>Launch Angle:</span>
                <span id="launch-angle">0Â°</span>
            </div>
            <div class="stat-item">
                <span>Distance:</span>
                <span id="distance">0 ft</span>
            </div>
            <div class="stat-item">
                <span>Win Probability:</span>
                <span id="win-prob">50%</span>
            </div>
        </div>
        
        <div class="momentum-bar">
            <div class="momentum-fill" id="momentum"></div>
        </div>
        
        <div class="ai-commentary" id="commentary"></div>
        
        <div class="controls">
            <button class="btn" onclick="simulatePitch()">Pitch Ball</button>
            <button class="btn" onclick="simulateHit()">Simulate Hit</button>
            <button class="btn" onclick="generateAIPlay()">AI Generate Play</button>
            <button class="btn" onclick="resetGame()">Reset Game</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js Baseball Simulator with Claude API Integration
        
        let scene, camera, renderer;
        let stadium, field, baseball;
        let cameras = {};
        let currentCamera = 'broadcast';
        let gameState = {
            homeScore: 0,
            awayScore: 0,
            inning: 1,
            topBottom: 'top',
            outs: 0,
            momentum: 50,
            lastPlay: null
        };
        
        // Initialize Three.js Scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 100, 1500);
            
            // Setup renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Setup cameras
            setupCameras();
            
            // Add lights
            setupLighting();
            
            // Create stadium
            createStadium();
            
            // Create field
            createField();
            
            // Create baseball
            createBaseball();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
        }
        
        function setupCameras() {
            // Broadcast camera
            cameras.broadcast = new THREE.PerspectiveCamera(
                60, window.innerWidth / window.innerHeight, 0.1, 2000
            );
            cameras.broadcast.position.set(150, 100, 150);
            cameras.broadcast.lookAt(0, 0, 0);
            
            // Pitcher view
            cameras.pitcher = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 2000
            );
            cameras.pitcher.position.set(0, 2, 20);
            cameras.pitcher.lookAt(0, 1, 0);
            
            // Batter view
            cameras.batter = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 2000
            );
            cameras.batter.position.set(0, 2, -2);
            cameras.batter.lookAt(0, 1, 20);
            
            // Aerial view
            cameras.aerial = new THREE.PerspectiveCamera(
                60, window.innerWidth / window.innerHeight, 0.1, 2000
            );
            cameras.aerial.position.set(0, 300, 0);
            cameras.aerial.lookAt(0, 0, 0);
            
            camera = cameras[currentCamera];
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Stadium lights
            const stadiumLights = [
                { x: 100, y: 150, z: 100 },
                { x: -100, y: 150, z: 100 },
                { x: 100, y: 150, z: -100 },
                { x: -100, y: 150, z: -100 }
            ];
            
            stadiumLights.forEach(pos => {
                const light = new THREE.SpotLight(0xffffff, 1, 500, Math.PI / 4, 0.5);
                light.position.set(pos.x, pos.y, pos.z);
                light.target.position.set(0, 0, 0);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;
                scene.add(light);
                scene.add(light.target);
            });
        }
        
        function createStadium() {
            // Stadium walls
            const wallGeometry = new THREE.BoxGeometry(400, 100, 10);
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2c3e50,
                emissive: 0x1a1a1a,
                emissiveIntensity: 0.2
            });
            
            // Back wall
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 50, -200);
            backWall.receiveShadow = true;
            scene.add(backWall);
            
            // Side walls
            const sideWallGeometry = new THREE.BoxGeometry(10, 100, 400);
            
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-200, 50, 0);
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(200, 50, 0);
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            
            // Stands (simplified)
            const standGeometry = new THREE.BoxGeometry(380, 50, 100);
            const standMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            
            const stands = new THREE.Mesh(standGeometry, standMaterial);
            stands.position.set(0, 25, -150);
            scene.add(stands);
        }
        
        function createField() {
            // Main field (grass)
            const fieldGeometry = new THREE.PlaneGeometry(400, 400);
            const fieldTexture = createGrassTexture();
            const fieldMaterial = new THREE.MeshPhongMaterial({ 
                map: fieldTexture,
                side: THREE.DoubleSide
            });
            
            field = new THREE.Mesh(fieldGeometry, fieldMaterial);
            field.rotation.x = -Math.PI / 2;
            field.receiveShadow = true;
            scene.add(field);
            
            // Infield (dirt)
            const infieldGeometry = new THREE.CircleGeometry(60, 32, 0, Math.PI / 2);
            const infieldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8b6914,
                side: THREE.DoubleSide
            });
            
            const infield = new THREE.Mesh(infieldGeometry, infieldMaterial);
            infield.rotation.x = -Math.PI / 2;
            infield.position.y = 0.1;
            scene.add(infield);
            
            // Bases
            const baseGeometry = new THREE.BoxGeometry(2, 0.2, 2);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            
            const bases = [
                { x: 30, z: 0 },   // First base
                { x: 0, z: 30 },   // Second base
                { x: -30, z: 0 },  // Third base
                { x: 0, z: 0 }     // Home plate
            ];
            
            bases.forEach(pos => {
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(pos.x, 0.1, pos.z);
                scene.add(base);
            });
            
            // Pitcher's mound
            const moundGeometry = new THREE.CylinderGeometry(3, 5, 1, 32);
            const moundMaterial = new THREE.MeshPhongMaterial({ color: 0x8b6914 });
            
            const mound = new THREE.Mesh(moundGeometry, moundMaterial);
            mound.position.set(0, 0.5, 18.44);
            scene.add(mound);
        }
        
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create grass pattern
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#2d5016');
            gradient.addColorStop(0.5, '#3a6218');
            gradient.addColorStop(1, '#2d5016');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add grass lines
            ctx.strokeStyle = '#4a7c1e';
            ctx.lineWidth = 2;
            for (let i = 0; i < 512; i += 20) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(512, i);
                ctx.stroke();
            }
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function createBaseball() {
            const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.1
            });
            
            baseball = new THREE.Mesh(ballGeometry, ballMaterial);
            baseball.position.set(0, 1, 18.44);
            baseball.castShadow = true;
            scene.add(baseball);
            
            // Add stitching (simplified)
            const stitchGeometry = new THREE.TorusGeometry(0.5, 0.02, 2, 100);
            const stitchMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const stitch1 = new THREE.Mesh(stitchGeometry, stitchMaterial);
            stitch1.rotation.y = Math.PI / 4;
            baseball.add(stitch1);
            
            const stitch2 = new THREE.Mesh(stitchGeometry, stitchMaterial);
            stitch2.rotation.y = -Math.PI / 4;
            baseball.add(stitch2);
        }
        
        function setCamera(cameraName) {
            currentCamera = cameraName;
            camera = cameras[cameraName];
            
            // Update button states
            document.querySelectorAll('.camera-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function simulatePitch() {
            // Reset ball position
            baseball.position.set(0, 1, 18.44);
            
            // Animate pitch
            const startPos = { x: 0, y: 1, z: 18.44 };
            const endPos = { x: Math.random() * 2 - 1, y: Math.random() * 2 + 0.5, z: 0 };
            
            animateBall(startPos, endPos, 500);
            
            // Generate AI commentary
            const pitchTypes = ['Fastball', 'Curveball', 'Slider', 'Changeup', 'Knuckleball'];
            const pitchType = pitchTypes[Math.floor(Math.random() * pitchTypes.length)];
            const velocity = Math.floor(Math.random() * 15 + 85);
            
            showCommentary(`${pitchType} at ${velocity} mph! The pitcher delivers with authority!`);
        }
        
        function simulateHit() {
            // Calculate hit physics
            const exitVelocity = Math.random() * 40 + 80;
            const launchAngle = Math.random() * 45 + 10;
            const direction = Math.random() * 90 - 45;
            
            // Update stats display
            document.getElementById('exit-velocity').textContent = `${exitVelocity.toFixed(1)} mph`;
            document.getElementById('launch-angle').textContent = `${launchAngle.toFixed(1)}Â°`;
            
            // Calculate distance
            const distance = calculateDistance(exitVelocity, launchAngle);
            document.getElementById('distance').textContent = `${distance.toFixed(0)} ft`;
            
            // Animate ball trajectory
            animateHitBall(exitVelocity, launchAngle, direction);
            
            // Determine outcome
            const outcome = determineOutcome(distance, direction);
            processPlay(outcome);
            
            // Generate AI commentary
            generateHitCommentary(outcome, distance);
        }
        
        function calculateDistance(velocity, angle) {
            // Simplified physics calculation
            const v0 = velocity * 0.44704; // mph to m/s
            const angleRad = angle * Math.PI / 180;
            const g = 9.81;
            
            const distance = (v0 * v0 * Math.sin(2 * angleRad)) / g;
            return distance * 3.28084; // meters to feet
        }
        
        function animateBall(start, end, duration) {
            const startTime = Date.now();
            
            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                baseball.position.x = start.x + (end.x - start.x) * progress;
                baseball.position.y = start.y + (end.y - start.y) * progress;
                baseball.position.z = start.z + (end.z - start.z) * progress;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            update();
        }
        
        function animateHitBall(velocity, angle, direction) {
            const startTime = Date.now();
            const duration = 3000;
            
            function update() {
                const elapsed = Date.now() - startTime;
                const t = elapsed / 1000;
                
                if (t < duration / 1000) {
                    // Projectile motion
                    const v0 = velocity * 0.44704;
                    const angleRad = angle * Math.PI / 180;
                    const dirRad = direction * Math.PI / 180;
                    
                    const x = v0 * Math.cos(angleRad) * Math.sin(dirRad) * t;
                    const z = v0 * Math.cos(angleRad) * Math.cos(dirRad) * t;
                    const y = v0 * Math.sin(angleRad) * t - 0.5 * 9.81 * t * t + 1;
                    
                    baseball.position.set(x, Math.max(0, y), z);
                    
                    requestAnimationFrame(update);
                } else {
                    baseball.position.y = 0;
                }
            }
            
            update();
        }
        
        function determineOutcome(distance, direction) {
            if (distance < 90) return 'out';
            if (distance < 200) return 'single';
            if (distance < 300) return 'double';
            if (distance < 380) return 'triple';
            return 'homerun';
        }
        
        function processPlay(outcome) {
            const currentTeam = gameState.topBottom === 'top' ? 'away' : 'home';
            
            switch(outcome) {
                case 'homerun':
                    if (currentTeam === 'home') {
                        gameState.homeScore += 1;
                        gameState.momentum = Math.min(90, gameState.momentum + 20);
                    } else {
                        gameState.awayScore += 1;
                        gameState.momentum = Math.max(10, gameState.momentum - 20);
                    }
                    break;
                case 'triple':
                case 'double':
                case 'single':
                    // Simplified scoring
                    if (Math.random() < 0.3) {
                        if (currentTeam === 'home') {
                            gameState.homeScore += 1;
                            gameState.momentum = Math.min(80, gameState.momentum + 10);
                        } else {
                            gameState.awayScore += 1;
                            gameState.momentum = Math.max(20, gameState.momentum - 10);
                        }
                    }
                    break;
                case 'out':
                    gameState.outs += 1;
                    if (gameState.outs >= 3) {
                        switchInning();
                    }
                    break;
            }
            
            updateUI();
        }
        
        function switchInning() {
            gameState.outs = 0;
            
            if (gameState.topBottom === 'top') {
                gameState.topBottom = 'bottom';
            } else {
                gameState.topBottom = 'top';
                gameState.inning += 1;
            }
        }
        
        function updateUI() {
            document.getElementById('home-score').textContent = gameState.homeScore;
            document.getElementById('away-score').textContent = gameState.awayScore;
            document.getElementById('inning').textContent = gameState.inning;
            document.getElementById('half').textContent = gameState.topBottom.toUpperCase();
            document.getElementById('momentum').style.width = `${gameState.momentum}%`;
            
            // Update win probability (simplified)
            const totalScore = gameState.homeScore + gameState.awayScore + 1;
            const homeProb = (gameState.homeScore / totalScore) * 50 + gameState.momentum / 2;
            document.getElementById('win-prob').textContent = `${homeProb.toFixed(0)}%`;
        }
        
        function showCommentary(text) {
            const commentary = document.getElementById('commentary');
            commentary.textContent = text;
            commentary.classList.add('active');
            
            setTimeout(() => {
                commentary.classList.remove('active');
            }, 5000);
        }
        
        function generateHitCommentary(outcome, distance) {
            const commentaries = {
                'homerun': [
                    `GONE! A majestic ${distance.toFixed(0)}-foot blast! The crowd goes wild!`,
                    `IT'S OUTTA HERE! ${distance.toFixed(0)} feet of pure power!`,
                    `CRUSHED! That ball is still going! ${distance.toFixed(0)} feet!`
                ],
                'triple': [
                    `A screaming liner to the gap! The runner is digging for third!`,
                    `That's triple territory! ${distance.toFixed(0)} feet of excitement!`
                ],
                'double': [
                    `Split the gap! That's a stand-up double!`,
                    `Off the wall! The runner cruises into second!`
                ],
                'single': [
                    `Base hit! Clean single through the infield!`,
                    `Drops in for a hit! Runner aboard!`
                ],
                'out': [
                    `Caught! The fielder makes the play!`,
                    `Routine fly ball for the out.`,
                    `Ground out to end the threat.`
                ]
            };
            
            const options = commentaries[outcome];
            const selected = options[Math.floor(Math.random() * options.length)];
            showCommentary(selected);
        }
        
        async function generateAIPlay() {
            // Simulate Claude API call for generative content
            // In production, this would call your actual Claude API endpoint
            
            showCommentary("ðŸ¤– AI generating unique play scenario...");
            
            // Simulate API delay
            setTimeout(() => {
                const scenarios = [
                    {
                        play: "The batter steps up with bases loaded. The tension is palpable as the pitcher winds up...",
                        outcome: "Grand slam to deep center field! The stadium erupts!",
                        score: 4
                    },
                    {
                        play: "Bottom of the 9th, two outs, runner on third. The closer faces the cleanup hitter...",
                        outcome: "Strike three! The closer pumps his fist as the team celebrates!",
                        score: 0
                    },
                    {
                        play: "The rookie's first at-bat in the big leagues. You can see the nerves...",
                        outcome: "First pitch swinging - a line drive single! What a debut!",
                        score: 0
                    },
                    {
                        play: "The pitcher has thrown 8 perfect innings. One more to go for history...",
                        outcome: "Ground ball to short... the throw... PERFECT GAME!",
                        score: 0
                    }
                ];
                
                const scenario = scenarios[Math.floor(Math.random() * scenarios.length)];
                
                // Show the play
                showCommentary(scenario.play);
                
                // After delay, show outcome
                setTimeout(() => {
                    showCommentary(scenario.outcome);
                    
                    // Update score if needed
                    if (scenario.score > 0) {
                        if (gameState.topBottom === 'bottom') {
                            gameState.homeScore += scenario.score;
                        } else {
                            gameState.awayScore += scenario.score;
                        }
                        updateUI();
                    }
                    
                    // Trigger visual effect
                    if (scenario.outcome.includes('Grand slam') || scenario.outcome.includes('PERFECT')) {
                        createFireworks();
                    }
                }, 3000);
            }, 2000);
        }
        
        function createFireworks() {
            // Simple particle effect for celebrations
            const particles = new THREE.Group();
            
            for (let i = 0; i < 50; i++) {
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(Math.random(), Math.random(), Math.random())
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    Math.random() * 100 - 50,
                    Math.random() * 50 + 50,
                    Math.random() * 100 - 50
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate and remove
            let frame = 0;
            function animateFireworks() {
                frame++;
                particles.children.forEach(p => {
                    p.position.y += Math.random() * 2 - 1;
                    p.position.x += Math.random() * 2 - 1;
                    p.position.z += Math.random() * 2 - 1;
                });
                
                if (frame < 60) {
                    requestAnimationFrame(animateFireworks);
                } else {
                    scene.remove(particles);
                }
            }
            animateFireworks();
        }
        
        function resetGame() {
            gameState = {
                homeScore: 0,
                awayScore: 0,
                inning: 1,
                topBottom: 'top',
                outs: 0,
                momentum: 50,
                lastPlay: null
            };
            
            baseball.position.set(0, 1, 18.44);
            updateUI();
            showCommentary("New game started! Play ball!");
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate baseball
            if (baseball) {
                baseball.rotation.y += 0.01;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            Object.values(cameras).forEach(cam => {
                cam.aspect = window.innerWidth / window.innerHeight;
                cam.updateProjectionMatrix();
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when page loads
        window.addEventListener('load', initScene);
    </script>
</body>
</html>